# .github/workflows/set-pr-status.yml
name: PR Status

on:
  pull_request:
    types:
      [
        opened,
        reopened,
        synchronize,
        edited,
        ready_for_review,
        converted_to_draft,
      ]
  pull_request_review:
    types: [submitted]

jobs:
  update-project-status:
    name: Update PR status for ethrex_l1 project
    runs-on: ubuntu-latest
    # sadly pull_request_review doesn't give me labels information so we'll have to check this later.
    if: github.event_name == 'pull_request_review' || contains(github.event.pull_request.labels.*.name, 'L1')
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PROJECT_PERSONAL_ACCESS_TOKEN }}
          script: |
            // ========== FUNCTIONS ==========

            // Gets a project given the number and the organization.
            async function getProject(org, number) {
              const res = await github.graphql(`
                query($org: String!) {
                  organization(login: $org) {
                    projectsV2(first: 100) {
                      nodes {
                        id
                        title
                        number
                      }
                    }
                  }
                }
              `, { org });
              const project = res.organization.projectsV2.nodes.find(p => p.number === number);
              if (!project) throw new Error(`Project #${number} not found in org ${org}`);
              return project;
            }

            // Get all items of a project.
            async function getAllProjectItems(projectId) {
              let hasNextPage = true;
              let after = null;
              let items = [];

              while (hasNextPage) {
                const res = await github.graphql(`
                  query($projectId: ID!, $after: String) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo {
                            hasNextPage
                            endCursor
                          }
                          nodes {
                            id
                            content {
                              ... on PullRequest {
                                number
                              }
                              ... on Issue {
                                number
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `, { projectId, after });

                items.push(...res.node.items.nodes);
                hasNextPage = res.node.items.pageInfo.hasNextPage;
                after = res.node.items.pageInfo.endCursor;
              }

              return items;
            }

            // Gets all fields of a project. Any kind of field.
            async function getProjectFields(projectId) {
              const res = await github.graphql(`
                query($projectId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options {
                              id
                              name
                            }
                          }
                          ... on ProjectV2IterationField {
                            id
                            name
                            configuration {
                              iterations {
                                id
                                title
                                startDate
                                duration
                              }
                            }
                          }
                          ... on ProjectV2FieldCommon {
                            id
                            name
                          }
                        }
                      }
                    }
                  }
                }
              `, { projectId });

              // Return an array of all fields with their options if available
              return res.node.fields.nodes;
            }


            // Sets a date field.
            async function setProjectItemDateField(projectId, itemId, field, dateValue) {
              const date = dateValue.split("T")[0]; // "YYYY-MM-DD"

              await github.graphql(`
                mutation {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: "${projectId}",
                    itemId: "${itemId}",
                    fieldId: "${field.id}",
                    value: { date: "${date}" }
                  }) {
                    projectV2Item { id }
                  }
                }
              `);

              console.log(`Set date field '${field.name}' to '${date}'.`);
            }

            // Sets the field for status to a project item (PR or Issue). E.g., Set Status for PR #100 to "In Progress".
            async function setProjectItemStatus(itemId, field, optionName, projectId) {
              // Ensure the field is a single select and has options
              if (!field.options) throw new Error(`Field '${field.name}' has no options`);

              // Find the matching option
              const option = field.options.find(opt => opt.name === optionName);
              if (!option) throw new Error(`Option '${optionName}' not found in field '${field.name}'`);

              // Run the mutation
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) {
                    projectV2Item { id }
                  }
                }
              `, {
                projectId,
                itemId,
                fieldId: field.id,
                optionId: option.id
              });
            }

            // Gets all issue numbers that would be closed if the PR is merged.
            function extractLinkedIssueNumbers(prBody) {
              const body = prBody || "";
              const withoutComments = body.replace(/<!--[\s\S]*?-->/g, "");
              const matches = [...withoutComments.matchAll(/(?:close[sd]?|fixe[sd]?|resolve[sd]?)\s+#(\d+)/gi)];
              return matches.map(match => parseInt(match[1], 10));
            }

            function findItemByNumber(allItems, number) {
              return allItems.find(i => i.content?.number === number);
            }


            // ========== MAIN LOGIC ==========
            const pr = context.payload.pull_request;

            // Continue with execution only if it ontains the l1 label.
            // This check is for the review, the check for a pull_request event was already done before.
            if (context.eventName === "pull_request_review") {
              const prNumber = pr.number;
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });

              const hasL1 = labels.some(label => label.name === "L1");
              if (!hasL1) {
                console.log("PR does not have 'L1' label. Exiting.");
                return;
              } else {
                console.log("PR contains 'L1' label. Continuing with status checks...")
              }
            }

            function getFieldByName(fields, fieldName) {
              const field = fields.find(f => f.name === fieldName);
              if (!field) throw new Error(`Field '${fieldName}' not found`);
              return field;
            }


            const projectNumber = 31;
            const orgLogin = "lambdaclass";

            // Get project and item representing Pull Request. Exiting early if it doesn't belong to the project.
            const project = await getProject(orgLogin, projectNumber);
            const projectId = project.id;

            const allItems = await getAllProjectItems(projectId);
            const pr_item = findItemByNumber(allItems, pr.number);
            if (!pr_item) {
              console.log(`PR #${pr.number} not found in ethrex_l1 project. Exiting...`);
              return;
            }

            // Get all fields of the project.
            const fields = await getProjectFields(projectId);

            const statusField = getFieldByName(fields, "Status");
            const lastUpdatedField = getFieldByName(fields, "Last updated");
            const startDateField = getFieldByName(fields, "Start date");

            const action = context.payload.action;

            // Set Start date if PR was opened
            if (action === "opened") {
              await setProjectItemDateField(projectId, pr_item.id, startDateField, pr.created_at);
            }

            // Set date of Last update only if it's an update to the PR
            if (action === "synchronize" || action === "edited") {
              await setProjectItemDateField(projectId, pr_item.id, lastUpdatedField, pr.updated_at);
            }

            let converted_to_draft = (action === "opened" || action === "reopened") && pr.draft || action === "converted_to_draft";
            let ready_for_review = action === "ready_for_review";
            let requested_changes = context.eventName === "pull_request_review" && context.payload.review?.state == "changes_requested";

            // Determine new status of the PR.
            let new_status = null;

            if (converted_to_draft) {
              new_status = "In Progress";
            } else if (ready_for_review) {
              new_status = "In Review";
            } else if (requested_changes) {
              new_status = "Requested Changes";
            }

            if (!new_status) {
              console.log("No status change required for this action.");
              return;
            }

            // Set new status of the PR
            console.log(`Setting new status of the PR to '${new_status}'`);
            await setProjectItemStatus(pr_item.id, statusField, new_status, projectId);

            // Set new status of each issue linked to the PR
            const issueNumbers = extractLinkedIssueNumbers(pr.body);
            console.log("Issues that this PR closes:", issueNumbers);

            console.log(`Synchronizing linked issues with new PR status.`);
            for (const issueNumber of issueNumbers) {
              const issueItem = findItemByNumber(allItems, issueNumber);

              if (issueItem) {
                console.log(`Setting status of issue #${issueNumber} to '${status}'.`);
                await setProjectItemStatus(issueItem.id, statusField, new_status, projectId);
              } else {
                console.warn(`Project item for issue #${issueNumber} not found.`);
              }
            }
