#![allow(clippy::unwrap_used)]
#![allow(clippy::expect_used)]
use bytes::Bytes;
use ethereum_types::{Address, U256};
use ethrex_common::H160;
use ethrex_common::types::BlockNumber;
use ethrex_l2_sdk::calldata::{self, Value};
use ethrex_l2_sdk::l1_to_l2_tx_data::L1ToL2TransactionData;
use ethrex_l2_sdk::{
    COMMON_BRIDGE_L2_ADDRESS, claim_erc20withdraw, deposit_erc20, get_address_from_secret_key,
    wait_for_transaction_receipt,
};
use ethrex_rpc::clients::eth::from_hex_string_to_u256;
use ethrex_rpc::clients::eth::{BlockByNumber, EthClient, eth_sender::Overrides};
use ethrex_rpc::types::receipt::RpcReceipt;
use hex::FromHexError;
use keccak_hash::{H256, keccak};
use secp256k1::SecretKey;
use std::fs::{File, read_to_string};
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::{ops::Mul, str::FromStr, time::Duration};

/// Test the full flow of depositing, depositing with contract call, transferring, and withdrawing funds
/// from L1 to L2 and back.
/// The test can be configured with the following environment variables
///
/// RPC urls:
/// INTEGRATION_TEST_ETH_URL: The url of the l1 rpc server
/// INTEGRATION_TEST_PROPOSER_URL: The url of the l2 rpc server
///
/// Accounts private keys:
/// INTEGRATION_TEST_L1_RICH_WALLET_PRIVATE_KEY: The l1 private key that will make the deposit to the l2 and the transfer to the second l2 account
/// INTEGRATION_TEST_RETURN_TRANSFER_PRIVATE_KEY: The l2 private key that will receive the deposit and the transfer it back to the L1_RICH_WALLET_PRIVATE_KEY
/// ETHREX_DEPLOYER_PRIVATE_KEYS_FILE_PATH: The path to a file with pks that are rich accounts in the l2
///
/// Contract addresses:
/// ETHREX_WATCHER_BRIDGE_ADDRESS: The address of the l1 bridge contract
/// INTEGRATION_TEST_PROPOSER_COINBASE_ADDRESS: The address of the l2 coinbase
///
/// Test parameters:
///
/// INTEGRATION_TEST_DEPOSIT_VALUE: amount in wei to deposit from L1_RICH_WALLET_PRIVATE_KEY to the l2, this amount will be deposited 3 times over the course of the test
/// INTEGRATION_TEST_TRANSFER_VALUE: amount in wei to transfer to INTEGRATION_TEST_RETURN_TRANSFER_PRIVATE_KEY, this amount will be returned to the account
/// INTEGRATION_TEST_WITHDRAW_VALUE: amount in wei to withdraw from the l2 back to the l1 from L1_RICH_WALLET_PRIVATE_KEY this will be done INTEGRATION_TEST_WITHDRAW_COUNT times
/// INTEGRATION_TEST_WITHDRAW_COUNT: amount of withdraw transactions to send
/// INTEGRATION_TEST_SKIP_TEST_TOTAL_ETH: if set the integration test will not check for total eth in the chain, only to be used if we don't know all the accounts that exist in l2
const DEFAULT_ETH_URL: &str = "http://localhost:8545";
const DEFAULT_PROPOSER_URL: &str = "http://localhost:1729";
// 0x941e103320615d394a55708be13e45994c7d93b932b064dbcb2b511fe3254e2e
const DEFAULT_L1_RICH_WALLET_PRIVATE_KEY: H256 = H256([
    0x94, 0x1e, 0x10, 0x33, 0x20, 0x61, 0x5d, 0x39, 0x4a, 0x55, 0x70, 0x8b, 0xe1, 0x3e, 0x45, 0x99,
    0x4c, 0x7d, 0x93, 0xb9, 0x32, 0xb0, 0x64, 0xdb, 0xcb, 0x2b, 0x51, 0x1f, 0xe3, 0x25, 0x4e, 0x2e,
]);
// 0xbcdf20249abf0ed6d944c0288fad489e33f66b3960d9e6229c1cd214ed3bbe31
const DEFAULT_L2_RETURN_TRANSFER_PRIVATE_KEY: H256 = H256([
    0xbc, 0xdf, 0x20, 0x24, 0x9a, 0xbf, 0x0e, 0xd6, 0xd9, 0x44, 0xc0, 0x28, 0x8f, 0xad, 0x48, 0x9e,
    0x33, 0xf6, 0x6b, 0x39, 0x60, 0xd9, 0xe6, 0x22, 0x9c, 0x1c, 0xd2, 0x14, 0xed, 0x3b, 0xbe, 0x31,
]);
// 0x8ccf74999c496e4d27a2b02941673f41dd0dab2a
const DEFAULT_BRIDGE_ADDRESS: Address = H160([
    0x8c, 0xcf, 0x74, 0x99, 0x9c, 0x49, 0x6e, 0x4d, 0x27, 0xa2, 0xb0, 0x29, 0x41, 0x67, 0x3f, 0x41,
    0xdd, 0x0d, 0xab, 0x2a,
]);
// 0x0007a881CD95B1484fca47615B64803dad620C8d
const DEFAULT_PROPOSER_COINBASE_ADDRESS: Address = H160([
    0x00, 0x07, 0xa8, 0x81, 0xcd, 0x95, 0xb1, 0x48, 0x4f, 0xca, 0x47, 0x61, 0x5b, 0x64, 0x80, 0x3d,
    0xad, 0x62, 0x0c, 0x8d,
]);

const L2_GAS_COST_MAX_DELTA: U256 = U256([100_000_000_000_000, 0, 0, 0]);

const DEFAULT_PRIVATE_KEYS_FILE_PATH: &str = "../../test_data/private_keys_l1.txt";

#[tokio::test]
async fn l2_integration_test() -> Result<(), Box<dyn std::error::Error>> {
    read_env_file_by_config();

    let eth_client = eth_client();
    let proposer_client = proposer_client();
    let rich_wallet_private_key = l1_rich_wallet_private_key();
    let transfer_return_private_key = l2_return_transfer_private_key();
    let bridge_address = common_bridge_address();
    let deposit_recipient_address = get_address_from_secret_key(&rich_wallet_private_key)
        .expect("Failed to get address from l1 rich wallet pk");

    test_deposit(
        &rich_wallet_private_key,
        bridge_address,
        deposit_recipient_address,
        &eth_client,
        &proposer_client,
    )
    .await?;

    test_transfer(
        &rich_wallet_private_key,
        &transfer_return_private_key,
        &proposer_client,
    )
    .await?;

    test_deposit_with_contract_call(deposit_recipient_address, &proposer_client, &eth_client)
        .await?;

    test_deposit_with_contract_call_revert(
        deposit_recipient_address,
        &proposer_client,
        &eth_client,
    )
    .await?;

    test_erc20_roundtrip(bridge_address, &proposer_client, &eth_client).await?;

    let withdrawals_count = std::env::var("INTEGRATION_TEST_WITHDRAW_COUNT")
        .map(|amount| amount.parse().expect("Invalid withdrawal amount value"))
        .unwrap_or(5);

    test_n_withdraws(
        &rich_wallet_private_key,
        &eth_client,
        &proposer_client,
        withdrawals_count,
    )
    .await?;

    if std::env::var("INTEGRATION_TEST_SKIP_TEST_TOTAL_ETH").is_err() {
        test_total_eth_l2(&eth_client, &proposer_client).await?;
    }

    println!("l2_integration_test is done");
    Ok(())
}

/// In this test we deploy a contract on L2 and call it from L1 using the CommonBridge contract.
/// We call the contract by making a deposit from L1 to L2 with the recipient being the rich account.
/// The deposit will trigger the call to the contract.
async fn test_deposit_with_contract_call(
    deposit_recipient_address: Address,
    proposer_client: &EthClient,
    eth_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    let rich_wallet_private_key = l1_rich_wallet_private_key();

    // pragma solidity ^0.8.27;
    // contract Test {
    //     event NumberSet(uint256 indexed number);
    //     function emitNumber(uint256 _number) public {
    //         emit NumberSet(_number);
    //     }
    // }
    let init_code = hex::decode(
        "6080604052348015600e575f5ffd5b506101008061001c5f395ff3fe6080604052348015600e575f5ffd5b50600436106026575f3560e01c8063f15d140b14602a575b5f5ffd5b60406004803603810190603c919060a4565b6042565b005b807f9ec8254969d1974eac8c74afb0c03595b4ffe0a1d7ad8a7f82ed31b9c854259160405160405180910390a250565b5f5ffd5b5f819050919050565b6086816076565b8114608f575f5ffd5b50565b5f81359050609e81607f565b92915050565b5f6020828403121560b65760b56072565b5b5f60c1848285016092565b9150509291505056fea26469706673582212206f6d360696127c56e2d2a456f3db4a61e30eae0ea9b3af3c900c81ea062e8fe464736f6c634300081c0033",
    )?;

    let deployed_contract_address =
        test_deploy(&init_code, &rich_wallet_private_key, proposer_client).await?;

    let number_to_emit = U256::from(424242);
    let calldata_to_contract: Bytes =
        calldata::encode_calldata("emitNumber(uint256)", &[Value::Uint(number_to_emit)])?.into();

    // We need to get the block number before the deposit to search for logs later.
    let first_block = proposer_client.get_block_number().await?;

    test_call_to_contract_with_deposit(
        deployed_contract_address,
        calldata_to_contract,
        &rich_wallet_private_key,
        proposer_client,
        eth_client,
        deposit_recipient_address,
    )
    .await?;

    println!("Waiting for event to be emitted");

    let mut block_number = first_block;

    let topic = keccak(b"NumberSet(uint256)");

    while proposer_client
        .get_logs(first_block, block_number, deployed_contract_address, topic)
        .await
        .is_ok_and(|logs| logs.is_empty())
    {
        println!("Waiting for the event to be built");
        block_number += U256::one();
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    }

    let logs = proposer_client
        .get_logs(first_block, block_number, deployed_contract_address, topic)
        .await?;

    let number_emitted = U256::from_big_endian(
        &logs
            .first()
            .unwrap()
            .log
            .topics
            .get(1)
            .unwrap()
            .to_fixed_bytes(),
    );

    assert_eq!(
        number_emitted, number_to_emit,
        "Event emitted with wrong value. Expected 424242, got {number_emitted}"
    );

    Ok(())
}

/// Test the deployment of a contract on L2 and call it from L1 using the CommonBridge contract.
/// The call to the contract should revert but the deposit should be successful.
async fn test_deposit_with_contract_call_revert(
    deposit_recipient_address: Address,
    proposer_client: &EthClient,
    eth_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    // pragma solidity ^0.8.27;
    // contract RevertTest {
    //     function revert_call() public {
    //         revert("Reverted");
    //     }
    // }
    let rich_wallet_private_key = l1_rich_wallet_private_key();
    let init_code = hex::decode(
        "6080604052348015600e575f5ffd5b506101138061001c5f395ff3fe6080604052348015600e575f5ffd5b50600436106026575f3560e01c806311ebce9114602a575b5f5ffd5b60306032565b005b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040160629060c1565b60405180910390fd5b5f82825260208201905092915050565b7f52657665727465640000000000000000000000000000000000000000000000005f82015250565b5f60ad600883606b565b915060b682607b565b602082019050919050565b5f6020820190508181035f83015260d68160a3565b905091905056fea2646970667358221220903f571921ce472f979989f9135b8637314b68e080fd70d0da6ede87ad8b5bd564736f6c634300081c0033",
    )?;

    let deployed_contract_address =
        test_deploy(&init_code, &rich_wallet_private_key, proposer_client).await?;

    let calldata_to_contract: Bytes = calldata::encode_calldata("revert_call()", &[])?.into();

    test_call_to_contract_with_deposit(
        deployed_contract_address,
        calldata_to_contract,
        &rich_wallet_private_key,
        proposer_client,
        eth_client,
        deposit_recipient_address,
    )
    .await?;

    Ok(())
}

async fn test_erc20_roundtrip(
    bridge_address: Address,
    l2_client: &EthClient,
    l1_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    let token_amount: U256 = U256::from(100);

    let rich_wallet_private_key = l1_rich_wallet_private_key();
    let rich_address = ethrex_l2_sdk::get_address_from_secret_key(&rich_wallet_private_key)
        .expect("Failed to get address");

    let init_code_l1 = hex::decode(
        "608060405234801561000f575f5ffd5b506040518060400160405280600881526020017f46756e546f6b656e0000000000000000000000000000000000000000000000008152506040518060400160405280600381526020017f46554e0000000000000000000000000000000000000000000000000000000000815250816003908161008b9190610598565b50806004908161009b9190610598565b5050506100b83369d3c21bcecceda10000006100bd60201b60201c565b61077c565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361012d575f6040517fec442f0500000000000000000000000000000000000000000000000000000000815260040161012491906106a6565b60405180910390fd5b61013e5f838361014260201b60201c565b5050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610192578060025f82825461018691906106ec565b92505081905550610260565b5f5f5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205490508181101561021b578381836040517fe450d38c0000000000000000000000000000000000000000000000000000000081526004016102129392919061072e565b60405180910390fd5b8181035f5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036102a7578060025f82825403925050819055506102f1565b805f5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161034e9190610763565b60405180910390a3505050565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806103d657607f821691505b6020821081036103e9576103e8610392565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f6008830261044b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610410565b6104558683610410565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f61049961049461048f8461046d565b610476565b61046d565b9050919050565b5f819050919050565b6104b28361047f565b6104c66104be826104a0565b84845461041c565b825550505050565b5f5f905090565b6104dd6104ce565b6104e88184846104a9565b505050565b5b8181101561050b576105005f826104d5565b6001810190506104ee565b5050565b601f82111561055057610521816103ef565b61052a84610401565b81016020851015610539578190505b61054d61054585610401565b8301826104ed565b50505b505050565b5f82821c905092915050565b5f6105705f1984600802610555565b1980831691505092915050565b5f6105888383610561565b9150826002028217905092915050565b6105a18261035b565b67ffffffffffffffff8111156105ba576105b9610365565b5b6105c482546103bf565b6105cf82828561050f565b5f60209050601f831160018114610600575f84156105ee578287015190505b6105f8858261057d565b86555061065f565b601f19841661060e866103ef565b5f5b8281101561063557848901518255600182019150602085019450602081019050610610565b86831015610652578489015161064e601f891682610561565b8355505b6001600288020188555050505b505050505050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61069082610667565b9050919050565b6106a081610686565b82525050565b5f6020820190506106b95f830184610697565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6106f68261046d565b91506107018361046d565b9250828201905080821115610719576107186106bf565b5b92915050565b6107288161046d565b82525050565b5f6060820190506107415f830186610697565b61074e602083018561071f565b61075b604083018461071f565b949350505050565b5f6020820190506107765f83018461071f565b92915050565b610e8c806107895f395ff3fe608060405234801561000f575f5ffd5b506004361061009c575f3560e01c80635b70ea9f116100645780635b70ea9f1461015a57806370a082311461016457806395d89b4114610194578063a9059cbb146101b2578063dd62ed3e146101e25761009c565b806306fdde03146100a0578063095ea7b3146100be57806318160ddd146100ee57806323b872dd1461010c578063313ce5671461013c575b5f5ffd5b6100a8610212565b6040516100b59190610b05565b60405180910390f35b6100d860048036038101906100d39190610bb6565b6102a2565b6040516100e59190610c0e565b60405180910390f35b6100f66102c4565b6040516101039190610c36565b60405180910390f35b61012660048036038101906101219190610c4f565b6102cd565b6040516101339190610c0e565b60405180910390f35b6101446102fb565b6040516101519190610cba565b60405180910390f35b610162610303565b005b61017e60048036038101906101799190610cd3565b610319565b60405161018b9190610c36565b60405180910390f35b61019c61035e565b6040516101a99190610b05565b60405180910390f35b6101cc60048036038101906101c79190610bb6565b6103ee565b6040516101d99190610c0e565b60405180910390f35b6101fc60048036038101906101f79190610cfe565b610410565b6040516102099190610c36565b60405180910390f35b60606003805461022190610d69565b80601f016020809104026020016040519081016040528092919081815260200182805461024d90610d69565b80156102985780601f1061026f57610100808354040283529160200191610298565b820191905f5260205f20905b81548152906001019060200180831161027b57829003601f168201915b5050505050905090565b5f5f6102ac610492565b90506102b9818585610499565b600191505092915050565b5f600254905090565b5f5f6102d7610492565b90506102e48582856104ab565b6102ef85858561053e565b60019150509392505050565b5f6012905090565b6103173369d3c21bcecceda100000061062e565b565b5f5f5f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b60606004805461036d90610d69565b80601f016020809104026020016040519081016040528092919081815260200182805461039990610d69565b80156103e45780601f106103bb576101008083540402835291602001916103e4565b820191905f5260205f20905b8154815290600101906020018083116103c757829003601f168201915b5050505050905090565b5f5f6103f8610492565b905061040581858561053e565b600191505092915050565b5f60015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905092915050565b5f33905090565b6104a683838360016106ad565b505050565b5f6104b68484610410565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8110156105385781811015610529578281836040517ffb8f41b200000000000000000000000000000000000000000000000000000000815260040161052093929190610da8565b60405180910390fd5b61053784848484035f6106ad565b5b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036105ae575f6040517f96c6fd1e0000000000000000000000000000000000000000000000000000000081526004016105a59190610ddd565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361061e575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016106159190610ddd565b60405180910390fd5b61062983838361087c565b505050565b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361069e575f6040517fec442f050000000000000000000000000000000000000000000000000000000081526004016106959190610ddd565b60405180910390fd5b6106a95f838361087c565b5050565b5f73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff160361071d575f6040517fe602df050000000000000000000000000000000000000000000000000000000081526004016107149190610ddd565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361078d575f6040517f94280d620000000000000000000000000000000000000000000000000000000081526004016107849190610ddd565b60405180910390fd5b8160015f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20819055508015610876578273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9258460405161086d9190610c36565b60405180910390a35b50505050565b5f73ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036108cc578060025f8282546108c09190610e23565b9250508190555061099a565b5f5f5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2054905081811015610955578381836040517fe450d38c00000000000000000000000000000000000000000000000000000000815260040161094c93929190610da8565b60405180910390fd5b8181035f5f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550505b5f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036109e1578060025f8282540392505081905550610a2b565b805f5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f82825401925050819055505b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610a889190610c36565b60405180910390a3505050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f610ad782610a95565b610ae18185610a9f565b9350610af1818560208601610aaf565b610afa81610abd565b840191505092915050565b5f6020820190508181035f830152610b1d8184610acd565b905092915050565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f610b5282610b29565b9050919050565b610b6281610b48565b8114610b6c575f5ffd5b50565b5f81359050610b7d81610b59565b92915050565b5f819050919050565b610b9581610b83565b8114610b9f575f5ffd5b50565b5f81359050610bb081610b8c565b92915050565b5f5f60408385031215610bcc57610bcb610b25565b5b5f610bd985828601610b6f565b9250506020610bea85828601610ba2565b9150509250929050565b5f8115159050919050565b610c0881610bf4565b82525050565b5f602082019050610c215f830184610bff565b92915050565b610c3081610b83565b82525050565b5f602082019050610c495f830184610c27565b92915050565b5f5f5f60608486031215610c6657610c65610b25565b5b5f610c7386828701610b6f565b9350506020610c8486828701610b6f565b9250506040610c9586828701610ba2565b9150509250925092565b5f60ff82169050919050565b610cb481610c9f565b82525050565b5f602082019050610ccd5f830184610cab565b92915050565b5f60208284031215610ce857610ce7610b25565b5b5f610cf584828501610b6f565b91505092915050565b5f5f60408385031215610d1457610d13610b25565b5b5f610d2185828601610b6f565b9250506020610d3285828601610b6f565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680610d8057607f821691505b602082108103610d9357610d92610d3c565b5b50919050565b610da281610b48565b82525050565b5f606082019050610dbb5f830186610d99565b610dc86020830185610c27565b610dd56040830184610c27565b949350505050565b5f602082019050610df05f830184610d99565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610e2d82610b83565b9150610e3883610b83565b9250828201905080821115610e5057610e4f610df6565b5b9291505056fea2646970667358221220c2ace90351a6254148d1d6fc391d67d42f65e41f9290478674caf67a0ec34ec964736f6c634300081b0033",
    )?;
    let init_code_l2_inner = "60806040523461002f576100196100146100f4565b610288565b610021610034565b610fc861053a8239610fc890f35b61003a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100669061003e565b810190811060018060401b0382111761007e57604052565b610048565b9061009661008f610034565b928361005c565b565b5f80fd5b60018060a01b031690565b6100b09061009c565b90565b6100bc816100a7565b036100c357565b5f80fd5b905051906100d4826100b3565b565b906020828203126100ef576100ec915f016100c7565b90565b610098565b6101126115028038038061010781610083565b9283398101906100d6565b90565b60018060401b0381116101315761012d60209161003e565b0190565b610048565b9061014861014383610115565b610083565b918252565b5f7f54657374546f6b656e4c32000000000000000000000000000000000000000000910152565b61017e600b610136565b9061018b6020830161014d565b565b610195610174565b90565b5f7f5445535400000000000000000000000000000000000000000000000000000000910152565b6101c96004610136565b906101d660208301610198565b565b6101e06101bf565b90565b90565b90565b6101fd6101f8610202926101e3565b6101e6565b61009c565b90565b61020e906101e9565b90565b5f1b90565b9061022760018060a01b0391610211565b9181191691161790565b61024561024061024a9261009c565b6101e6565b61009c565b90565b61025690610231565b90565b6102629061024d565b90565b90565b9061027d61027861028492610259565b610265565b8254610216565b9055565b6102bf906102a561029761018d565b61029f6101d8565b906102c1565b6102b86102b15f610205565b6005610268565b6005610268565b565b906102cb91610521565b565b5190565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610305575b602083101461030057565b6102d1565b91607f16916102f5565b5f5260205f2090565b601f602091010490565b1b90565b9190600861034191029161033b5f1984610322565b92610322565b9181191691161790565b90565b61036261035d6103679261034b565b6101e6565b61034b565b90565b90565b919061038361037e61038b9361034e565b61036a565b908354610326565b9055565b5f90565b6103a59161039f61038f565b9161036d565b565b5b8181106103b3575050565b806103c05f600193610393565b016103a8565b9190601f81116103d6575b505050565b6103e26104079361030f565b9060206103ee84610318565b8301931061040f575b61040090610318565b01906103a7565b5f80806103d1565b9150610400819290506103f7565b1c90565b90610431905f199060080261041d565b191690565b8161044091610421565b906002021790565b90610452816102cd565b9060018060401b038211610510576104748261046e85546102e5565b856103c6565b602090601f83116001146104a857918091610497935f9261049c575b5050610436565b90555b565b90915001515f80610490565b601f198316916104b78561030f565b925f5b8181106104f8575091600293918560019694106104de575b5050500201905561049a565b6104ee910151601f841690610421565b90555f80806104d2565b919360206001819287870151815501950192016104ba565b610048565b9061051f91610448565b565b90610530610537926003610515565b6004610515565b56fe60806040526004361015610013575b61062d565b61001d5f356100ec565b806306fdde03146100e7578063095ea7b3146100e257806318160ddd146100dd57806323b872dd146100d8578063313ce567146100d357806335b35ad3146100ce57806340c10f19146100c957806370a08231146100c457806395d89b41146100bf578063a9059cbb146100ba578063c2eeeebd146100b5578063dd62ed3e146100b05763ee9a31a20361000e576105f8565b6105b1565b61054f565b610519565b6104e4565b6104af565b61045d565b610423565b610388565b61032a565b6102bb565b610263565b61017a565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261010a57565b6100fc565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61015061015960209361015e936101478161010f565b93848093610113565b9586910161011c565b610127565b0190565b6101779160208201915f818403910152610131565b90565b346101aa5761018a366004610100565b6101a661019561078a565b61019d6100f2565b91829182610162565b0390f35b6100f8565b60018060a01b031690565b6101c3906101af565b90565b6101cf816101ba565b036101d657565b5f80fd5b905035906101e7826101c6565b565b90565b6101f5816101e9565b036101fc57565b5f80fd5b9050359061020d826101ec565b565b9190604083820312610237578061022b610234925f86016101da565b93602001610200565b90565b6100fc565b151590565b61024a9061023c565b9052565b9190610261905f60208501940190610241565b565b346102945761029061027f61027936600461020f565b906107a4565b6102876100f2565b9182918261024e565b0390f35b6100f8565b6102a2906101e9565b9052565b91906102b9905f60208501940190610299565b565b346102eb576102cb366004610100565b6102e76102d66107f3565b6102de6100f2565b918291826102a6565b0390f35b6100f8565b90916060828403126103255761032261030b845f85016101da565b9361031981602086016101da565b93604001610200565b90565b6100fc565b3461035b576103576103466103403660046102f0565b91610809565b61034e6100f2565b9182918261024e565b0390f35b6100f8565b60ff1690565b61036f90610360565b9052565b9190610386905f60208501940190610366565b565b346103b857610398366004610100565b6103b46103a361085e565b6103ab6100f2565b91829182610373565b0390f35b6100f8565b1c90565b60018060a01b031690565b6103dc9060086103e193026103bd565b6103c1565b90565b906103ef91546103cc565b90565b6103fe60055f906103e4565b90565b61040a906101ba565b9052565b9190610421905f60208501940190610401565b565b3461045357610433366004610100565b61044f61043e6103f2565b6104466100f2565b9182918261040e565b0390f35b6100f8565b5f0190565b3461048c5761047661047036600461020f565b9061091c565b61047e6100f2565b8061048881610458565b0390f35b6100f8565b906020828203126104aa576104a7915f016101da565b90565b6100fc565b346104df576104db6104ca6104c5366004610491565b610995565b6104d26100f2565b918291826102a6565b0390f35b6100f8565b34610514576104f4366004610100565b6105106104ff6109b3565b6105076100f2565b91829182610162565b0390f35b6100f8565b3461054a5761054661053561052f36600461020f565b906109c9565b61053d6100f2565b9182918261024e565b0390f35b6100f8565b3461057f5761055f366004610100565b61057b61056a610a10565b6105726100f2565b9182918261040e565b0390f35b6100f8565b91906040838203126105ac57806105a06105a9925f86016101da565b936020016101da565b90565b6100fc565b346105e2576105de6105cd6105c7366004610584565b90610a3c565b6105d56100f2565b918291826102a6565b0390f35b6100f8565b61ffff90565b6105f56105e7565b90565b3461062857610608366004610100565b6106246106136105ed565b61061b6100f2565b9182918261040e565b0390f35b6100f8565b5f80fd5b606090565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561066a575b602083101461066557565b610636565b91607f169161065a565b60209181520190565b5f5260205f2090565b905f92918054906106a06106998361064a565b8094610674565b916001811690815f146106f757506001146106bb575b505050565b6106c8919293945061067d565b915f925b8184106106df57505001905f80806106b6565b600181602092959395548486015201910192906106cc565b92949550505060ff19168252151560200201905f80806106b6565b9061071c91610686565b90565b634e487b7160e01b5f52604160045260245ffd5b9061073d90610127565b810190811067ffffffffffffffff82111761075757604052565b61071f565b9061077c6107759261076c6100f2565b93848092610712565b0383610733565b565b6107879061075c565b90565b610792610631565b5061079d600361077e565b90565b5f90565b6107c1916107b06107a0565b506107b9610a64565b919091610a71565b600190565b5f90565b5f1c90565b90565b6107de6107e3916107ca565b6107cf565b90565b6107f090546107d2565b90565b6107fb6107c6565b5061080660026107e6565b90565b91610833926108166107a0565b5061082b610822610a64565b82908491610ac1565b919091610b78565b600190565b5f90565b90565b90565b61085661085161085b9261083c565b61083f565b610360565b90565b610866610838565b506108716012610842565b90565b60207f7400000000000000000000000000000000000000000000000000000000000000917f54657374546f6b656e3a206e6f7420617574686f72697a656420746f206d696e5f8201520152565b6108ce6021604092610113565b6108d781610874565b0190565b6108f09060208101905f8183039101526108c1565b90565b156108fa57565b6109026100f2565b62461bcd60e51b815280610918600482016108db565b0390fd5b90610949916109443361093e6109386109336105e7565b6101ba565b916101ba565b146108f3565b610c15565b565b61095f61095a610964926101af565b61083f565b6101af565b90565b6109709061094b565b90565b61097c90610967565b90565b9061098990610973565b5f5260205260405f2090565b6109ab6109b0916109a46107c6565b505f61097f565b6107e6565b90565b6109bb610631565b506109c6600461077e565b90565b6109e6916109d56107a0565b506109de610a64565b919091610b78565b600190565b5f90565b6109fb610a00916107ca565b6103c1565b90565b610a0d90546109ef565b90565b610a186109eb565b50610a236005610a03565b90565b90610a3090610973565b5f5260205260405f2090565b610a6191610a57610a5c92610a4f6107c6565b506001610a26565b61097f565b6107e6565b90565b610a6c6109eb565b503390565b91610a7f9291600192610ccd565b565b604090610aaa610ab19496959396610aa060608401985f850190610401565b6020830190610299565b0190610299565b565b90610abe91036101e9565b90565b929192610acf818390610a3c565b9081610ae4610ade5f196101e9565b916101e9565b10610af1575b5050509050565b81610b04610afe876101e9565b916101e9565b10610b2a57610b219394610b19919392610ab3565b905f92610ccd565b805f8080610aea565b50610b49849291925f938493637dc7a0d960e11b855260048501610a81565b0390fd5b90565b610b64610b5f610b6992610b4d565b61083f565b6101af565b90565b610b7590610b50565b90565b9182610b94610b8e610b895f610b6c565b6101ba565b916101ba565b14610bee5781610bb4610bae610ba95f610b6c565b6101ba565b916101ba565b14610bc757610bc592919091610e23565b565b610bea610bd35f610b6c565b5f91829163ec442f0560e01b83526004830161040e565b0390fd5b610c11610bfa5f610b6c565b5f918291634b637e8f60e11b83526004830161040e565b0390fd5b80610c30610c2a610c255f610b6c565b6101ba565b916101ba565b14610c4c57610c4a91610c425f610b6c565b919091610e23565b565b610c6f610c585f610b6c565b5f91829163ec442f0560e01b83526004830161040e565b0390fd5b5f1b90565b90610c845f1991610c73565b9181191691161790565b610ca2610c9d610ca7926101e9565b61083f565b6101e9565b90565b90565b90610cc2610cbd610cc992610c8e565b610caa565b8254610c78565b9055565b909281610cea610ce4610cdf5f610b6c565b6101ba565b916101ba565b14610db55783610d0a610d04610cff5f610b6c565b6101ba565b916101ba565b14610d8e57610d2e83610d29610d2260018690610a26565b879061097f565b610cad565b610d38575b505050565b919091610d83610d71610d6b7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593610973565b93610973565b93610d7a6100f2565b918291826102a6565b0390a35f8080610d33565b610db1610d9a5f610b6c565b5f918291634a1406b160e11b83526004830161040e565b0390fd5b610dd8610dc15f610b6c565b5f91829163e602df0560e01b83526004830161040e565b0390fd5b634e487b7160e01b5f52601160045260245ffd5b610dff610e05919392936101e9565b926101e9565b8201809211610e1057565b610ddc565b90610e2091016101e9565b90565b91909180610e41610e3b610e365f610b6c565b6101ba565b916101ba565b145f14610f2257610e65610e5e83610e5960026107e6565b610df0565b6002610cad565b5b82610e81610e7b610e765f610b6c565b6101ba565b916101ba565b145f14610ef657610ea5610e9e83610e9960026107e6565b610ab3565b6002610cad565b5b919091610ef1610edf610ed97fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610973565b93610973565b93610ee86100f2565b918291826102a6565b0390a3565b610f1d82610f17610f085f879061097f565b91610f12836107e6565b610e15565b90610cad565b610ea6565b610f35610f305f839061097f565b6107e6565b80610f48610f42856101e9565b916101e9565b10610f7057610f5b610f6b918490610ab3565b610f665f849061097f565b610cad565b610e66565b90610f8e9091925f93849363391434e360e21b855260048501610a81565b0390fdfea2646970667358221220ceac409703e43c8b2c22cec379576cf314ce1d0ea50935a0e66904c27cbb529864736f6c634300081d0033";

    let token_l1 = test_deploy_l1(&init_code_l1, &rich_wallet_private_key, l1_client).await?;
    let init_code_l2 =
        hex::decode(format!("{init_code_l2_inner}{:x}", H256::from(token_l1))).unwrap();

    let token_l2 = test_deploy(&init_code_l2, &rich_wallet_private_key, l2_client).await?;

    println!("token l1={token_l1:x}, l2={token_l2:x}");
    test_send(
        l1_client,
        &rich_wallet_private_key,
        token_l1,
        "freeMint()",
        &[],
    )
    .await;
    test_send(
        l1_client,
        &rich_wallet_private_key,
        token_l1,
        "approve(address,uint256)",
        &[Value::Address(bridge_address), Value::Uint(token_amount)],
    )
    .await;
    let initial_balance = test_balance_of(l1_client, token_l1, rich_address).await;
    let deposit_tx = deposit_erc20(
        token_l1,
        token_l2,
        token_amount,
        rich_address,
        rich_wallet_private_key,
        l1_client,
    )
    .await
    .unwrap();
    let res = wait_for_transaction_receipt(deposit_tx, l1_client, 10)
        .await
        .unwrap();
    wait_for_l2_deposit_receipt(res.block_info.block_number, l1_client, l2_client)
        .await
        .unwrap();
    let remaining_l1_balance = test_balance_of(l1_client, token_l1, rich_address).await;
    let l2_balance = test_balance_of(l2_client, token_l2, rich_address).await;
    assert_eq!(initial_balance - remaining_l1_balance, token_amount);
    assert_eq!(l2_balance, token_amount);

    test_send(
        l2_client,
        &rich_wallet_private_key,
        token_l2,
        "approve(address,uint256)",
        &[
            Value::Address(COMMON_BRIDGE_L2_ADDRESS),
            Value::Uint(token_amount),
        ],
    )
    .await;
    let res = test_send(
        l2_client,
        &rich_wallet_private_key,
        COMMON_BRIDGE_L2_ADDRESS,
        "withdrawERC20(address,address,address,uint256)",
        &[
            Value::Address(token_l1),
            Value::Address(token_l2),
            Value::Address(rich_address),
            Value::Uint(token_amount),
        ],
    )
    .await;
    let proof = l2_client
        .wait_for_message_proof(res.tx_info.transaction_hash, 1000)
        .await;
    let proof = proof.unwrap().into_iter().next().expect("proof not found");

    let on_chain_proposer_address = Address::from_str(
        &std::env::var("ETHREX_COMMITTER_ON_CHAIN_PROPOSER_ADDRESS")
            .expect("ETHREX_COMMITTER_ON_CHAIN_PROPOSER_ADDRESS env var not set"),
    )
    .unwrap();
    while l1_client
        .get_last_verified_batch(on_chain_proposer_address)
        .await
        .unwrap()
        < proof.batch_number
    {
        println!("Withdrawal is not verified on L1 yet");
        tokio::time::sleep(Duration::from_secs(2)).await;
    }

    let withdraw_claim_tx = claim_erc20withdraw(
        token_l1,
        token_l2,
        token_amount,
        res.tx_info.transaction_hash,
        rich_wallet_private_key,
        l1_client,
        &proof,
    )
    .await
    .expect("error while claiming");
    wait_for_transaction_receipt(withdraw_claim_tx, l1_client, 5).await?;
    let l1_final_balance = test_balance_of(l1_client, token_l1, rich_address).await;
    let l2_final_balance = test_balance_of(l2_client, token_l2, rich_address).await;
    assert_eq!(initial_balance, l1_final_balance);
    assert!(l2_final_balance.is_zero());
    Ok(())
}

async fn test_balance_of(client: &EthClient, token: Address, user: Address) -> U256 {
    let res = client
        .call(
            token,
            ethrex_l2_sdk::calldata::encode_calldata("balanceOf(address)", &[Value::Address(user)])
                .unwrap()
                .into(),
            Default::default(),
        )
        .await
        .unwrap();
    from_hex_string_to_u256(&res).unwrap()
}

async fn test_send(
    client: &EthClient,
    private_key: &SecretKey,
    to: Address,
    signature: &str,
    data: &[Value],
) -> RpcReceipt {
    let caller_address =
        ethrex_l2_sdk::get_address_from_secret_key(private_key).expect("Failed to get address");
    let tx = client
        .build_eip1559_transaction(
            to,
            caller_address,
            ethrex_l2_sdk::calldata::encode_calldata(signature, data)
                .unwrap()
                .into(),
            Default::default(),
        )
        .await
        .unwrap();
    let tx_hash = client
        .send_eip1559_transaction(&tx, private_key)
        .await
        .unwrap();
    ethrex_l2_sdk::wait_for_transaction_receipt(tx_hash, client, 10)
        .await
        .unwrap()
}

async fn test_deposit(
    depositor_private_key: &SecretKey,
    bridge_address: Address,
    deposit_recipient_address: Address,
    eth_client: &EthClient,
    proposer_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("Fetching initial balances on L1 and L2");

    let depositor = ethrex_l2_sdk::get_address_from_secret_key(depositor_private_key)?;
    let deposit_value = std::env::var("INTEGRATION_TEST_DEPOSIT_VALUE")
        .map(|value| U256::from_dec_str(&value).expect("Invalid deposit value"))
        .unwrap_or(U256::from(1000000000000000000000u128));

    let depositor_l1_initial_balance = eth_client
        .get_balance(depositor, BlockByNumber::Latest)
        .await?;

    assert!(
        depositor_l1_initial_balance >= deposit_value,
        "L1 depositor doesn't have enough balance to deposit"
    );

    let deposit_recipient_l2_initial_balance = proposer_client
        .get_balance(deposit_recipient_address, BlockByNumber::Latest)
        .await?;

    let bridge_initial_balance = eth_client
        .get_balance(bridge_address, BlockByNumber::Latest)
        .await?;

    let fee_vault_balance_before_deposit = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    println!("Depositing funds from L1 to L2");

    let deposit_tx_hash = ethrex_l2_sdk::deposit_through_contract_call(
        deposit_value,
        deposit_recipient_address,
        21000 * 10,
        21000 * 10,
        depositor_private_key,
        bridge_address,
        eth_client,
    )
    .await?;

    println!("Waiting for L1 deposit transaction receipt");

    let deposit_tx_receipt =
        ethrex_l2_sdk::wait_for_transaction_receipt(deposit_tx_hash, eth_client, 5).await?;

    let depositor_l1_balance_after_deposit = eth_client
        .get_balance(depositor, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        depositor_l1_balance_after_deposit,
        depositor_l1_initial_balance
            - deposit_value
            - deposit_tx_receipt.tx_info.gas_used * deposit_tx_receipt.tx_info.effective_gas_price,
        "Depositor L1 balance didn't decrease as expected after deposit"
    );

    let bridge_balance_after_deposit = eth_client
        .get_balance(bridge_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        bridge_balance_after_deposit,
        bridge_initial_balance + deposit_value,
        "Bridge balance didn't increase as expected after deposit"
    );

    println!("Waiting for L2 deposit tx receipt");

    let _ = wait_for_l2_deposit_receipt(
        deposit_tx_receipt.block_info.block_number,
        eth_client,
        proposer_client,
    )
    .await?;

    let deposit_recipient_l2_balance_after_deposit = proposer_client
        .get_balance(deposit_recipient_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        deposit_recipient_l2_balance_after_deposit,
        deposit_recipient_l2_initial_balance + deposit_value,
        "Deposit recipient L2 balance didn't increase as expected after deposit"
    );

    let fee_vault_balance_after_deposit = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    assert_eq!(
        fee_vault_balance_after_deposit, fee_vault_balance_before_deposit,
        "Fee vault balance should not change after deposit"
    );

    Ok(())
}

async fn test_transfer(
    transferer_private_key: &SecretKey,
    returnerer_private_key: &SecretKey,
    proposer_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("Transferring funds on L2");
    let transfer_value = std::env::var("INTEGRATION_TEST_TRANSFER_VALUE")
        .map(|value| U256::from_dec_str(&value).expect("Invalid transfer value"))
        .unwrap_or(U256::from(10000000000u128));
    let transferer_address = get_address_from_secret_key(transferer_private_key)?;
    let returner_address = get_address_from_secret_key(returnerer_private_key)?;

    perform_transfer(
        proposer_client,
        transferer_private_key,
        returner_address,
        transfer_value,
    )
    .await?;
    // Only return 99% of the transfer, other amount is for fees
    let return_amount = (transfer_value * 99) / 100;

    perform_transfer(
        proposer_client,
        returnerer_private_key,
        transferer_address,
        return_amount,
    )
    .await?;

    Ok(())
}

async fn perform_transfer(
    proposer_client: &EthClient,
    transferer_private_key: &SecretKey,
    transfer_recipient_address: Address,
    transfer_value: U256,
) -> Result<(), Box<dyn std::error::Error>> {
    let transferer_address = ethrex_l2_sdk::get_address_from_secret_key(transferer_private_key)?;

    let transferer_initial_l2_balance = proposer_client
        .get_balance(transferer_address, BlockByNumber::Latest)
        .await?;

    assert!(
        transferer_initial_l2_balance >= transfer_value,
        "L2 transferer doesn't have enough balance to transfer"
    );

    let transfer_recipient_initial_balance = proposer_client
        .get_balance(transfer_recipient_address, BlockByNumber::Latest)
        .await?;

    let fee_vault_balance_before_transfer = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    let transfer_tx = ethrex_l2_sdk::transfer(
        transfer_value,
        transferer_address,
        transfer_recipient_address,
        transferer_private_key,
        proposer_client,
    )
    .await?;

    let transfer_tx_receipt =
        ethrex_l2_sdk::wait_for_transaction_receipt(transfer_tx, proposer_client, 1000).await?;

    let recoverable_fees_vault_balance = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    println!("Recoverable Fees Balance: {recoverable_fees_vault_balance}",);

    println!("Checking balances on L2 after transfer");

    let transferer_l2_balance_after_transfer = proposer_client
        .get_balance(transferer_address, BlockByNumber::Latest)
        .await?;

    assert!(
        (transferer_initial_l2_balance - transfer_value)
            .abs_diff(transferer_l2_balance_after_transfer)
            < L2_GAS_COST_MAX_DELTA,
        "L2 transferer balance didn't decrease as expected after transfer. Gas costs were {}/{L2_GAS_COST_MAX_DELTA}",
        (transferer_initial_l2_balance - transfer_value)
            .abs_diff(transferer_l2_balance_after_transfer)
    );

    let transfer_recipient_l2_balance_after_transfer = proposer_client
        .get_balance(transfer_recipient_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        transfer_recipient_l2_balance_after_transfer,
        transfer_recipient_initial_balance + transfer_value,
        "L2 transfer recipient balance didn't increase as expected after transfer"
    );

    let fee_vault_balance_after_transfer = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    let transfer_fees = get_fees_details_l2(transfer_tx_receipt, proposer_client).await;

    assert_eq!(
        fee_vault_balance_after_transfer,
        fee_vault_balance_before_transfer + transfer_fees.recoverable_fees,
        "Fee vault balance didn't increase as expected after transfer"
    );

    Ok(())
}

async fn test_n_withdraws(
    withdrawer_private_key: &SecretKey,
    eth_client: &EthClient,
    proposer_client: &EthClient,
    n: u64,
) -> Result<(), Box<dyn std::error::Error>> {
    // Withdraw funds from L2 to L1
    let withdrawer_address = ethrex_l2_sdk::get_address_from_secret_key(withdrawer_private_key)?;
    let withdraw_value = std::env::var("INTEGRATION_TEST_WITHDRAW_VALUE")
        .map(|value| U256::from_dec_str(&value).expect("Invalid withdraw value"))
        .unwrap_or(U256::from(100000000000000000000u128));

    println!("Checking balances on L1 and L2 before withdrawal");

    let withdrawer_l2_balance_before_withdrawal = proposer_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    assert!(
        withdrawer_l2_balance_before_withdrawal >= withdraw_value,
        "L2 withdrawer doesn't have enough balance to withdraw"
    );

    let bridge_balance_before_withdrawal = eth_client
        .get_balance(common_bridge_address(), BlockByNumber::Latest)
        .await?;

    assert!(
        bridge_balance_before_withdrawal >= withdraw_value,
        "L1 bridge doesn't have enough balance to withdraw"
    );

    let withdrawer_l1_balance_before_withdrawal = eth_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    let fee_vault_balance_before_withdrawal = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    println!("Withdrawing funds from L2 to L1");

    let mut withdraw_txs = vec![];
    let mut receipts = vec![];

    for x in 1..n + 1 {
        println!("Sending withdraw {x}/{n}");
        let withdraw_tx = ethrex_l2_sdk::withdraw(
            withdraw_value,
            withdrawer_address,
            *withdrawer_private_key,
            proposer_client,
        )
        .await?;

        withdraw_txs.push(withdraw_tx);

        let withdraw_tx_receipt =
            ethrex_l2_sdk::wait_for_transaction_receipt(withdraw_tx, proposer_client, 1000)
                .await
                .expect("Withdraw tx receipt not found");

        receipts.push(withdraw_tx_receipt);
    }

    println!("Checking balances on L1 and L2 after withdrawal");

    let withdrawer_l2_balance_after_withdrawal = proposer_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    assert!(
        (withdrawer_l2_balance_before_withdrawal - withdraw_value * n)
            .abs_diff(withdrawer_l2_balance_after_withdrawal)
            < L2_GAS_COST_MAX_DELTA * n,
        "Withdrawer L2 balance didn't decrease as expected after withdrawal"
    );

    let withdrawer_l1_balance_after_withdrawal = eth_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        withdrawer_l1_balance_after_withdrawal, withdrawer_l1_balance_before_withdrawal,
        "Withdrawer L1 balance should not change after withdrawal"
    );

    let fee_vault_balance_after_withdrawal = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    let mut withdraw_fees = U256::zero();
    for receipt in receipts {
        withdraw_fees += get_fees_details_l2(receipt, proposer_client)
            .await
            .recoverable_fees;
    }

    assert_eq!(
        fee_vault_balance_after_withdrawal,
        fee_vault_balance_before_withdrawal + withdraw_fees,
        "Fee vault balance didn't increase as expected after withdrawal"
    );

    // We need to wait for all the txs to be included in some batch
    let mut proofs = vec![];
    for (i, tx) in withdraw_txs.clone().into_iter().enumerate() {
        println!("Getting withdrawal proof {}/{n}", i + 1);
        let message_proof = proposer_client.wait_for_message_proof(tx, 1000).await?;
        let withdrawal_proof = message_proof
            .into_iter()
            .next()
            .expect("no l1messages in withdrawal");
        proofs.push(withdrawal_proof);
    }

    let on_chain_proposer_address = Address::from_str(
        &std::env::var("ETHREX_COMMITTER_ON_CHAIN_PROPOSER_ADDRESS")
            .expect("ETHREX_COMMITTER_ON_CHAIN_PROPOSER_ADDRESS env var not set"),
    )
    .unwrap();
    for proof in &proofs {
        while eth_client
            .get_last_verified_batch(on_chain_proposer_address)
            .await
            .unwrap()
            < proof.batch_number
        {
            println!("Withdrawal is not verified on L1 yet");
            tokio::time::sleep(Duration::from_secs(2)).await;
        }
    }

    let mut withdraw_claim_txs_receipts = vec![];

    for (x, (tx, proof)) in withdraw_txs.iter().zip(proofs.iter()).enumerate() {
        println!("Claiming withdrawal on L1 {x}/{n}");

        let withdraw_claim_tx = ethrex_l2_sdk::claim_withdraw(
            withdraw_value,
            *tx,
            withdrawer_address,
            *withdrawer_private_key,
            eth_client,
            proof,
        )
        .await?;
        let withdraw_claim_tx_receipt =
            wait_for_transaction_receipt(withdraw_claim_tx, eth_client, 5).await?;
        withdraw_claim_txs_receipts.push(withdraw_claim_tx_receipt);
    }

    println!("Checking balances on L1 and L2 after claim");

    let withdrawer_l1_balance_after_claim = eth_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    let gas_used_value: u64 = withdraw_claim_txs_receipts
        .iter()
        .map(|x| x.tx_info.gas_used * x.tx_info.effective_gas_price)
        .sum();

    assert_eq!(
        withdrawer_l1_balance_after_claim,
        withdrawer_l1_balance_after_withdrawal + withdraw_value * n - gas_used_value,
        "Withdrawer L1 balance wasn't updated as expected after claim"
    );

    let withdrawer_l2_balance_after_claim = proposer_client
        .get_balance(withdrawer_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        withdrawer_l2_balance_after_claim, withdrawer_l2_balance_after_withdrawal,
        "Withdrawer L2 balance should not change after claim"
    );

    let bridge_balance_after_withdrawal = eth_client
        .get_balance(common_bridge_address(), BlockByNumber::Latest)
        .await?;

    assert_eq!(
        bridge_balance_after_withdrawal,
        bridge_balance_before_withdrawal - withdraw_value * n,
        "Bridge balance didn't decrease as expected after withdrawal"
    );

    Ok(())
}

async fn test_total_eth_l2(
    eth_client: &EthClient,
    proposer_client: &EthClient,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("Checking total ETH on L2");

    println!("Fetching rich accounts balance on L2");
    let rich_accounts_balance = get_rich_accounts_balance(proposer_client)
        .await
        .expect("Failed to get rich accounts balance");

    let coinbase_balance = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    println!("Coinbase balance: {coinbase_balance}");

    let total_eth_on_l2 = rich_accounts_balance + coinbase_balance;

    println!("Total ETH on L2: {rich_accounts_balance} + {coinbase_balance} = {total_eth_on_l2}");

    println!("Checking locked ETH on CommonBridge");

    let bridge_address = common_bridge_address();
    let bridge_locked_eth = eth_client
        .get_balance(bridge_address, BlockByNumber::Latest)
        .await?;

    println!("Bridge locked ETH: {bridge_locked_eth}");

    assert!(
        total_eth_on_l2 <= bridge_locked_eth,
        "Total ETH on L2 ({total_eth_on_l2}) is greater than bridge locked ETH ({bridge_locked_eth})"
    );

    Ok(())
}

async fn test_deploy(
    init_code: &[u8],
    deployer_private_key: &SecretKey,
    proposer_client: &EthClient,
) -> Result<Address, Box<dyn std::error::Error>> {
    println!("Deploying contract on L2");

    let deployer_address = ethrex_l2_sdk::get_address_from_secret_key(deployer_private_key)?;

    let deployer_balance_before_deploy = proposer_client
        .get_balance(deployer_address, BlockByNumber::Latest)
        .await?;

    let fee_vault_balance_before_deploy = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    let (deploy_tx_hash, contract_address) = proposer_client
        .deploy(
            deployer_address,
            *deployer_private_key,
            init_code.to_vec().into(),
            Overrides::default(),
        )
        .await?;

    let deploy_tx_receipt =
        ethrex_l2_sdk::wait_for_transaction_receipt(deploy_tx_hash, proposer_client, 5).await?;

    let deploy_fees = get_fees_details_l2(deploy_tx_receipt, proposer_client).await;

    let deployer_balance_after_deploy = proposer_client
        .get_balance(deployer_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        deployer_balance_after_deploy,
        deployer_balance_before_deploy - deploy_fees.total_fees,
        "Deployer L2 balance didn't decrease as expected after deploy"
    );

    let fee_vault_balance_after_deploy = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    assert_eq!(
        fee_vault_balance_after_deploy,
        fee_vault_balance_before_deploy + deploy_fees.recoverable_fees,
        "Fee vault balance didn't increase as expected after deploy"
    );

    let deployed_contract_balance = proposer_client
        .get_balance(contract_address, BlockByNumber::Latest)
        .await?;

    assert!(
        deployed_contract_balance.is_zero(),
        "Deployed contract balance should be zero after deploy"
    );

    Ok(contract_address)
}

async fn test_deploy_l1(
    init_code: &[u8],
    private_key: &SecretKey,
    client: &EthClient,
) -> Result<Address, Box<dyn std::error::Error>> {
    println!("Deploying contract on L1");

    let deployer_address = ethrex_l2_sdk::get_address_from_secret_key(private_key)?;

    let (deploy_tx_hash, contract_address) = client
        .deploy(
            deployer_address,
            *private_key,
            init_code.to_vec().into(),
            Overrides::default(),
        )
        .await?;

    ethrex_l2_sdk::wait_for_transaction_receipt(deploy_tx_hash, client, 5).await?;

    Ok(contract_address)
}

async fn test_call_to_contract_with_deposit(
    deployed_contract_address: Address,
    calldata_to_contract: Bytes,
    caller_private_key: &SecretKey,
    proposer_client: &EthClient,
    eth_client: &EthClient,
    deposit_recipient_address: Address,
) -> Result<(), Box<dyn std::error::Error>> {
    let caller_address = ethrex_l2_sdk::get_address_from_secret_key(caller_private_key)
        .expect("Failed to get address");

    let deposit_value = std::env::var("INTEGRATION_TEST_DEPOSIT_VALUE")
        .map(|value| U256::from_dec_str(&value).expect("Invalid deposit value"))
        .unwrap_or(U256::from(100000000000000000000u128));

    println!("Checking balances before call");

    let caller_l1_balance_before_call = eth_client
        .get_balance(caller_address, BlockByNumber::Latest)
        .await?;

    assert!(
        caller_l1_balance_before_call >= deposit_value,
        "Caller doesn't have enough balance on L1 to deposit"
    );

    let deployed_contract_balance_before_call = proposer_client
        .get_balance(deployed_contract_address, BlockByNumber::Latest)
        .await?;

    let recipient_balance_before_call = proposer_client
        .get_balance(deposit_recipient_address, BlockByNumber::Latest)
        .await?;

    let fee_vault_balance_before_call = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    println!("Calling contract on L2 with deposit");

    let l1_to_l2_tx_hash = ethrex_l2_sdk::send_l1_to_l2_tx(
        caller_address,
        Some(deposit_value),
        Some(21000 * 5),
        L1ToL2TransactionData::new(
            deployed_contract_address,
            deposit_recipient_address,
            21000 * 5,
            calldata_to_contract.clone(),
        ),
        &l1_rich_wallet_private_key(),
        common_bridge_address(),
        eth_client,
    )
    .await?;

    println!("Waiting for L1 to L2 transaction receipt on L1");

    let l1_to_l2_tx_receipt = wait_for_transaction_receipt(l1_to_l2_tx_hash, eth_client, 5).await?;

    println!("Waiting for L1 to L2 transaction receipt on L2");

    let _ = wait_for_l2_deposit_receipt(
        l1_to_l2_tx_receipt.block_info.block_number,
        eth_client,
        proposer_client,
    )
    .await?;

    println!("Checking balances after call");

    let caller_l1_balance_after_call = eth_client
        .get_balance(caller_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        caller_l1_balance_after_call,
        caller_l1_balance_before_call
            - deposit_value
            - l1_to_l2_tx_receipt.tx_info.gas_used
                * l1_to_l2_tx_receipt.tx_info.effective_gas_price,
        "Caller L1 balance didn't decrease as expected after call"
    );

    let deposit_recipient_l2_balance_after_call = proposer_client
        .get_balance(deposit_recipient_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        deposit_recipient_l2_balance_after_call,
        recipient_balance_before_call + deposit_value,
        "Recipient L2 balance didn't increase as expected after call"
    );

    let fee_vault_balance_after_call = proposer_client
        .get_balance(fees_vault(), BlockByNumber::Latest)
        .await?;

    assert_eq!(
        fee_vault_balance_after_call, fee_vault_balance_before_call,
        "Fee vault balance increased unexpectedly after call"
    );

    let deployed_contract_balance_after_call = proposer_client
        .get_balance(deployed_contract_address, BlockByNumber::Latest)
        .await?;

    assert_eq!(
        deployed_contract_balance_after_call, deployed_contract_balance_before_call,
        "Deployed contract increased unexpectedly after call"
    );

    Ok(())
}

// FIXME: Remove this before merging
#[allow(dead_code)]
#[derive(Debug)]
struct FeesDetails {
    total_fees: U256,
    recoverable_fees: U256,
    burned_fees: U256,
}

async fn get_fees_details_l2(tx_receipt: RpcReceipt, proposer_client: &EthClient) -> FeesDetails {
    let total_fees: U256 =
        (tx_receipt.tx_info.gas_used * tx_receipt.tx_info.effective_gas_price).into();

    let effective_gas_price = tx_receipt.tx_info.effective_gas_price;
    let base_fee_per_gas = proposer_client
        .get_block_by_number(BlockByNumber::Number(tx_receipt.block_info.block_number))
        .await
        .unwrap()
        .header
        .base_fee_per_gas
        .unwrap();

    let max_priority_fee_per_gas_transfer: U256 = (effective_gas_price - base_fee_per_gas).into();

    let recoverable_fees = max_priority_fee_per_gas_transfer.mul(tx_receipt.tx_info.gas_used);

    FeesDetails {
        total_fees,
        recoverable_fees,
        burned_fees: total_fees - recoverable_fees,
    }
}

fn eth_client() -> EthClient {
    EthClient::new(
        &std::env::var("INTEGRATION_TEST_ETH_URL").unwrap_or(DEFAULT_ETH_URL.to_string()),
    )
    .unwrap()
}

fn proposer_client() -> EthClient {
    EthClient::new(
        &std::env::var("INTEGRATION_TEST_PROPOSER_URL").unwrap_or(DEFAULT_PROPOSER_URL.to_string()),
    )
    .unwrap()
}

fn common_bridge_address() -> Address {
    std::env::var("ETHREX_WATCHER_BRIDGE_ADDRESS")
        .expect("ETHREX_WATCHER_BRIDGE_ADDRESS env var not set")
        .parse()
        .unwrap_or_else(|_| {
            println!(
                "ETHREX_WATCHER_BRIDGE_ADDRESS env var not set, using default: {DEFAULT_BRIDGE_ADDRESS}"
            );
            DEFAULT_BRIDGE_ADDRESS
        })
}

fn fees_vault() -> Address {
    std::env::var("INTEGRATION_TEST_PROPOSER_COINBASE_ADDRESS")
        .map(|address| address.parse().expect("Invalid proposer coinbase address"))
        .unwrap_or(DEFAULT_PROPOSER_COINBASE_ADDRESS)
}

fn l1_rich_wallet_private_key() -> SecretKey {
    let l1_rich_wallet_pk = std::env::var("INTEGRATION_TEST_L1_RICH_WALLET_PRIVATE_KEY")
        .map(|pk| pk.parse().expect("Invalid l1 rich wallet pk"))
        .unwrap_or(DEFAULT_L1_RICH_WALLET_PRIVATE_KEY);
    SecretKey::from_slice(l1_rich_wallet_pk.as_bytes()).unwrap()
}

fn l2_return_transfer_private_key() -> SecretKey {
    let l2_return_deposit_private_key =
        std::env::var("INTEGRATION_TEST_RETURN_TRANSFER_PRIVATE_KEY")
            .map(|pk| pk.parse().expect("Invalid l1 rich wallet pk"))
            .unwrap_or(DEFAULT_L2_RETURN_TRANSFER_PRIVATE_KEY);
    SecretKey::from_slice(l2_return_deposit_private_key.as_bytes()).unwrap()
}

async fn wait_for_l2_deposit_receipt(
    l1_receipt_block_number: BlockNumber,
    eth_client: &EthClient,
    proposer_client: &EthClient,
) -> Result<RpcReceipt, Box<dyn std::error::Error>> {
    let topic =
        keccak(b"DepositInitiated(uint256,address,uint256,address,address,uint256,bytes,bytes32)");
    let logs = eth_client
        .get_logs(
            U256::from(l1_receipt_block_number),
            U256::from(l1_receipt_block_number),
            common_bridge_address(),
            topic,
        )
        .await?;

    let l2_deposit_tx_hash =
        H256::from_slice(logs.first().unwrap().log.data.get(128..160).unwrap());

    println!("Waiting for deposit transaction receipt on L2");

    Ok(
        ethrex_l2_sdk::wait_for_transaction_receipt(l2_deposit_tx_hash, proposer_client, 1000)
            .await?,
    )
}

pub fn read_env_file_by_config() {
    let env_file_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join(".env");
    let reader = BufReader::new(File::open(env_file_path).expect("Failed to open .env file"));

    for line in reader.lines() {
        let line = line.expect("Failed to read line");
        if line.starts_with("#") {
            // Skip comments
            continue;
        };
        match line.split_once('=') {
            Some((key, value)) => {
                if std::env::vars().any(|(k, _)| k == key) {
                    continue;
                }
                unsafe { std::env::set_var(key, value) }
            }
            None => continue,
        };
    }
}

async fn get_rich_accounts_balance(
    proposer_client: &EthClient,
) -> Result<U256, Box<dyn std::error::Error>> {
    let mut total_balance = U256::zero();
    let private_keys_file_path = private_keys_file_path();

    let pks = read_to_string(private_keys_file_path)?;
    let private_keys: Vec<String> = pks
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| line.trim().to_string())
        .collect();

    for pk in private_keys.iter() {
        let secret_key = parse_private_key(pk)?;
        let address = get_address_from_secret_key(&secret_key)?;
        let get_balance = proposer_client
            .get_balance(address, BlockByNumber::Latest)
            .await?;
        total_balance += get_balance;
    }
    Ok(total_balance)
}

fn private_keys_file_path() -> PathBuf {
    match std::env::var("ETHREX_DEPLOYER_PRIVATE_KEYS_FILE_PATH") {
        Ok(path) => PathBuf::from(path),
        Err(_) => {
            println!(
                "ETHREX_DEPLOYER_PRIVATE_KEYS_FILE_PATH not set, using default: {}",
                DEFAULT_PRIVATE_KEYS_FILE_PATH
            );
            PathBuf::from(DEFAULT_PRIVATE_KEYS_FILE_PATH)
        }
    }
}

pub fn parse_private_key(s: &str) -> Result<SecretKey, Box<dyn std::error::Error>> {
    Ok(SecretKey::from_slice(&parse_hex(s)?)?)
}

pub fn parse_hex(s: &str) -> Result<Bytes, FromHexError> {
    match s.strip_prefix("0x") {
        Some(s) => hex::decode(s).map(Into::into),
        None => hex::decode(s).map(Into::into),
    }
}
