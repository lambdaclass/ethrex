use ethereum_rust_storage::Store;
use ethereum_rust_vm::execution_db::ExecutionDB;
use serde::{Deserialize, Serialize};
use std::{
    io::{BufReader, BufWriter},
    net::{IpAddr, Shutdown, TcpListener, TcpStream},
    sync::mpsc::{self, Receiver},
};
use tokio::signal::unix::{signal, SignalKind};
use tracing::{debug, info, warn};

use ethereum_rust_core::types::{Block, BlockHeader};

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct ProverInputData {
    pub db: ExecutionDB,
    pub block: Block,
    pub parent_header: BlockHeader,
}

use crate::utils::config::prover_server::ProverServerConfig;

use super::errors::ProverServerError;

pub async fn start_prover_server(store: Store) {
    let config = ProverServerConfig::from_env().expect("ProverServerConfig::from_env()");
    let mut prover_server = ProverServer::new_from_config(config.clone(), store);

    let (tx, rx) = mpsc::channel();

    let server = tokio::spawn(async move {
        prover_server
            .start(rx)
            .await
            .expect("prover_server.start()")
    });

    ProverServer::handle_sigint(tx, config).await;

    tokio::try_join!(server).expect("tokio::try_join!()");
}

/// Enum for the ProverServer <--> ProverClient Communication Protocol.
#[derive(Debug, Serialize, Deserialize)]
pub enum ProofData {
    /// 1.
    /// The Client initiates the connection with a RequestCheck.
    /// This acts as a "handshake" to verify that the block number stored in
    /// both components matches. The ProverServer is expected to run continuously.
    ///
    /// If the Client crashes, it will request the first block,
    /// which should have already been proven.
    RequestCheck,

    /// 2.
    /// After the Client sends a RequestCheck with a block number,
    /// it receives a RequestAck containing the last proven block
    /// registered by the Server.
    ///
    /// The Client checks whether the requested block matches
    /// last_proven_block + 1. If it does not, the last_proven_block
    /// is assigned to the ProverClient's `block_number_to_request` field,
    /// and a new Request is made with the correct block number.
    RequestAck { last_proven_block: u64 },

    /// 3.
    /// Once the Client and Server have synchronized their block numbers,
    /// the Client sends a Request for the next block.
    Request { block_number: u64 },

    /// 4.
    /// The Server responds with a Response containing the ProverInputData
    /// for the requested block.
    /// If the block_number requested > latest_block_number from [ProverServer::store]
    /// the Response will be ProofData::Response{None, None}.
    /// So that the Client knows that the Request couldn't be performed.
    Response {
        block_number: Option<u64>,
        input: Option<ProverInputData>,
    },

    /// 5.
    /// The Client submits the zk Proof generated by the prover
    /// for the specified block.
    Submit {
        block_number: u64,
        // zk Proof
        receipt: Box<risc0_zkvm::Receipt>,
    },

    /// 6.
    /// The Server acknowledges the receipt of the proof and updates its state,
    /// enabling the Client to also update its state and request the next block.
    SubmitAck { block_number: u64 },
}

struct ProverServer {
    ip: IpAddr,
    port: u16,
    store: Store,
    last_proven_block: u64,
}

impl ProverServer {
    pub fn new_from_config(config: ProverServerConfig, store: Store) -> Self {
        Self {
            ip: config.listen_ip,
            port: config.listen_port,
            store,
            last_proven_block: 0_u64,
        }
    }

    async fn handle_sigint(tx: mpsc::Sender<()>, config: ProverServerConfig) {
        let mut sigint = signal(SignalKind::interrupt()).expect("Failed to create SIGINT stream");
        sigint.recv().await.expect("signal.recv()");
        tx.send(()).expect("Failed to send shutdown signal");
        TcpStream::connect(format!("{}:{}", config.listen_ip, config.listen_port))
            .expect("TcpStream::connect()")
            .shutdown(Shutdown::Both)
            .expect("TcpStream::shutdown()");
    }

    pub async fn start(&mut self, rx: Receiver<()>) -> Result<(), ProverServerError> {
        let listener = TcpListener::bind(format!("{}:{}", self.ip, self.port))?;

        info!("Starting TCP server at {}:{}", self.ip, self.port);
        for stream in listener.incoming() {
            if let Ok(()) = rx.try_recv() {
                info!("Shutting down Prover Server");
                break;
            }

            debug!("Connection established!");
            self.handle_connection(stream?).await;
        }
        Ok(())
    }

    async fn handle_connection(&mut self, mut stream: TcpStream) {
        let buf_reader = BufReader::new(&stream);

        let data: Result<ProofData, _> = serde_json::de::from_reader(buf_reader);
        match data {
            Ok(ProofData::RequestCheck) => {
                if let Err(e) = self.handle_request_check(&mut stream).await {
                    warn!("Failed to handle submit: {e}");
                }
            }
            Ok(ProofData::Request { block_number }) => {
                assert!(block_number == (self.last_proven_block + 1), "Prover Client requested an invalid block_number: {block_number}. The last_proved_block is: {}", self.last_proven_block);
                if let Err(e) = self.handle_request(&mut stream, block_number).await {
                    warn!("Failed to handle request: {e}");
                }
            }
            Ok(ProofData::Submit {
                block_number,
                receipt,
            }) => {
                if let Err(e) = self.handle_submit(&mut stream, block_number, receipt) {
                    warn!("Failed to handle submit: {e}");
                }
                assert!(block_number == (self.last_proven_block + 1), "Prover Client submitted an invalid block_number: {block_number}. The last_proved_block is: {}", self.last_proven_block);
                self.last_proven_block = block_number;
            }
            Err(e) => {
                warn!("Failed to parse request: {e}");
            }
            _ => {
                warn!("Invalid request");
            }
        }

        debug!("Connection closed");
    }

    async fn handle_request_check(&self, stream: &mut TcpStream) -> Result<(), String> {
        debug!("RequestCheck received");

        let request_ack = ProofData::RequestAck {
            last_proven_block: self.last_proven_block,
        };
        let writer = BufWriter::new(stream);
        serde_json::to_writer(writer, &request_ack).map_err(|e| e.to_string())
    }

    async fn handle_request(
        &self,
        stream: &mut TcpStream,
        block_number: u64,
    ) -> Result<(), String> {
        debug!("Request received");

        let latest_block_number = self
            .store
            .get_latest_block_number()
            .map_err(|e| e.to_string())?
            .unwrap();

        let response = if block_number > latest_block_number {
            ProofData::Response {
                block_number: None,
                input: None,
            }
        } else {
            let input = self.create_prover_input(block_number)?;
            ProofData::Response {
                block_number: Some(block_number),
                input: Some(input),
            }
        };

        info!("Sent Response for block_number: {block_number}");

        let writer = BufWriter::new(stream);
        serde_json::to_writer(writer, &response).map_err(|e| e.to_string())
    }

    fn handle_submit(
        &self,
        stream: &mut TcpStream,
        block_number: u64,
        receipt: Box<risc0_zkvm::Receipt>,
    ) -> Result<(), String> {
        info!(
            "Submit received. Block Number: {block_number}, proof type: {:?}",
            receipt
        );

        // TODO: Verify the groth16 proof on chain.
        // helpful links:
        // https://docs.rs/risc0-zkvm/1.1.2/risc0_zkvm/struct.Groth16Receipt.html
        // https://dev.risczero.com/api/blockchain-integration/contracts/verifier -> RISC0's Verification Contract.
        //
        // To get the groth16 proof we will have to do something like:
        // receipt.inner.groth16().unwrap();
        // Many implementations make use of Bonsai, check if it is strictly necessary.

        let response = ProofData::SubmitAck { block_number };
        let writer = BufWriter::new(stream);
        serde_json::to_writer(writer, &response).map_err(|e| e.to_string())
    }

    fn create_prover_input(&self, block_number: u64) -> Result<ProverInputData, String> {
        let header = self
            .store
            .get_block_header(block_number)
            .map_err(|err| err.to_string())?
            .ok_or("block header not found")?;
        let body = self
            .store
            .get_block_body(block_number)
            .map_err(|err| err.to_string())?
            .ok_or("block body not found")?;

        let block = Block::new(header, body);

        let db = ExecutionDB::from_exec(&block, &self.store).map_err(|err| err.to_string())?;

        let parent_header = self
            .store
            .get_block_header_by_hash(block.header.parent_hash)
            .map_err(|err| err.to_string())?
            .ok_or("missing parent header".to_string())?;

        debug!("Created prover input for block {block_number}");

        Ok(ProverInputData {
            db,
            block,
            parent_header,
        })
    }
}
