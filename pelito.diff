diff --git a/crates/blockchain/mempool.rs b/crates/blockchain/mempool.rs
index e7f40f704..d4d4f37d5 100644
--- a/crates/blockchain/mempool.rs
+++ b/crates/blockchain/mempool.rs
@@ -1,5 +1,5 @@
 use std::{
-    collections::{HashMap, HashSet},
+    collections::{BTreeMap, HashMap, HashSet},
     sync::{Mutex, RwLock},
 };
 
@@ -12,7 +12,7 @@ use crate::{
     error::MempoolError,
 };
 use ethrex_common::{
-    Address, H256, U256,
+    Address, H160, H256, U256,
     types::{BlobsBundle, BlockHeader, ChainConfig, MempoolTransaction, Transaction, TxType},
 };
 use ethrex_storage::error::StoreError;
@@ -21,6 +21,7 @@ use ethrex_storage::error::StoreError;
 pub struct Mempool {
     transaction_pool: RwLock<HashMap<H256, MempoolTransaction>>,
     blobs_bundle_pool: Mutex<HashMap<H256, BlobsBundle>>,
+    txs_by_sender_nonce: RwLock<BTreeMap<(H160, u64), H256>>,
 }
 impl Mempool {
     pub fn new() -> Self {
@@ -33,11 +34,14 @@ impl Mempool {
         hash: H256,
         transaction: MempoolTransaction,
     ) -> Result<(), StoreError> {
-        let mut tx_pool = self
-            .transaction_pool
+        self.txs_by_sender_nonce
             .write()
-            .map_err(|error| StoreError::MempoolWriteLock(error.to_string()))?;
-        tx_pool.insert(hash, transaction);
+            .map_err(|error| StoreError::MempoolWriteLock(error.to_string()))?
+            .insert((transaction.sender(), transaction.nonce()), hash);
+        self.transaction_pool
+            .write()
+            .map_err(|error| StoreError::MempoolWriteLock(error.to_string()))?
+            .insert(hash, transaction);
 
         Ok(())
     }
@@ -79,6 +83,10 @@ impl Mempool {
                     .remove(&tx.compute_hash());
             }
 
+            self.txs_by_sender_nonce
+                .write()
+                .map_err(|error| StoreError::MempoolWriteLock(error.to_string()))?
+                .remove(&(tx.sender(), tx.nonce()));
             tx_pool.remove(hash);
         };
 
@@ -97,9 +105,15 @@ impl Mempool {
             .blobs_bundle_pool
             .lock()
             .map_err(|error| StoreError::Custom(error.to_string()))?;
+        let mut by_sender_nonce = self
+            .txs_by_sender_nonce
+            .write()
+            .map_err(|error| StoreError::MempoolWriteLock(error.to_string()))?;
         for hash in hashes {
-            tx_pool.remove(&hash);
             blobs_pool.remove(&hash);
+            if let Some(tx) = tx_pool.remove(&hash) {
+                by_sender_nonce.remove(&(tx.sender(), tx.nonce()));
+            }
         }
 
         Ok(())
@@ -126,6 +140,16 @@ impl Mempool {
             blobs_pool.clear();
             count
         };
+        // Ignored, they should map 1:1 to tx_pool
+        let _by_sender_nonce_count = {
+            let mut by_sender_nonce = self
+                .txs_by_sender_nonce
+                .write()
+                .map_err(|error| StoreError::Custom(error.to_string()))?;
+            let count = by_sender_nonce.len();
+            by_sender_nonce.clear();
+            count
+        };
 
         Ok(tx_pool_size + blobs_pool_size)
     }
@@ -228,21 +252,13 @@ impl Mempool {
     }
 
     pub fn get_nonce(&self, address: &Address) -> Result<Option<u64>, MempoolError> {
-        let pending_filter = PendingTxFilter {
-            min_tip: None,
-            base_fee: None,
-            blob_fee: None,
-            only_plain_txs: false,
-            only_blob_txs: false,
-        };
-
-        let pending_txs = self.filter_transactions(&pending_filter)?;
-        let nonce = match pending_txs.get(address) {
-            Some(txs) => txs.last().map(|tx| tx.nonce() + 1),
-            None => None,
-        };
-
-        Ok(nonce)
+        Ok(self
+            .txs_by_sender_nonce
+            .read()
+            .map_err(|error| StoreError::MempoolReadLock(error.to_string()))?
+            .range((*address, 0)..=(*address, u64::MAX))
+            .last()
+            .map(|((_address, nonce), _hash)| nonce + 1))
     }
 
     pub fn get_mempool_size(&self) -> Result<(usize, usize), MempoolError> {
@@ -294,23 +310,25 @@ impl Mempool {
         nonce: u64,
         received_hash: H256,
     ) -> Result<Option<MempoolTransaction>, MempoolError> {
-        let pooled_transactions = self
+        let Some(hash) = self
+            .txs_by_sender_nonce
+            .read()
+            .map_err(|error| StoreError::MempoolReadLock(error.to_string()))?
+            .get(&(sender, nonce))
+            .cloned()
+        else {
+            return Ok(None);
+        };
+        if hash == received_hash {
+            return Ok(None);
+        }
+
+        let transaction_pool = self
             .transaction_pool
             .read()
             .map_err(|error| StoreError::MempoolReadLock(error.to_string()))?;
-
-        let mut txs = pooled_transactions
-            .iter()
-            .filter_map(|(hash, tx)| {
-                if tx.sender() == sender && tx.nonce() == nonce && *hash != received_hash {
-                    Some(tx.clone())
-                } else {
-                    None
-                }
-            })
-            .collect::<Vec<_>>();
-
-        Ok(txs.pop())
+        let tx = transaction_pool.get(&hash).cloned();
+        Ok(tx)
     }
 
     pub fn find_tx_to_replace(
