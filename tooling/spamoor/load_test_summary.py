#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Summarize block execution throughput metrics from an ethrex load test log."
    )
    parser.add_argument(
        "log_file",
        type=Path,
        help="Path to the load test log file generated by load-test.sh",
    )
    return parser.parse_args()


def collect_metrics(log_path: Path) -> tuple[list[float], list[tuple[int, int, int, int]]]:
    metric_re = re.compile(r"\[METRIC\] BLOCK EXECUTION THROUGHPUT \((\d+)\): ([0-9.]+) Ggas/s")
    percent_re = re.compile(r"exec: (\d+)% merkle: (\d+)% store: (\d+)%")

    non_zero_throughput: list[float] = []
    rows: list[tuple[int, int, int, int]] = []

    for line in log_path.read_text(encoding="utf-8").splitlines():
        metric_match = metric_re.search(line)
        if not metric_match:
            continue
        block_number = int(metric_match.group(1))
        ggas = float(metric_match.group(2))
        if ggas > 0:
            non_zero_throughput.append(ggas)
        percent_match = percent_re.search(line)
        if percent_match and ggas > 0:
            rows.append(
                (
                    block_number,
                    int(percent_match.group(1)),
                    int(percent_match.group(2)),
                    int(percent_match.group(3)),
                )
            )

    return non_zero_throughput, rows


def print_summary(non_zero_throughput: list[float]) -> None:
    if non_zero_throughput:
        average = sum(non_zero_throughput) / len(non_zero_throughput)
        print(f"  Average Ggas/s (non-zero): {average:.3f}")
        print(f"  Max Ggas/s: {max(non_zero_throughput):.3f}")
        print(f"  Min Ggas/s: {min(non_zero_throughput):.3f}")
    else:
        print("  No non-zero throughput metrics found.")


def print_table(rows: list[tuple[int, int, int, int]]) -> None:
    if not rows:
        print("  No per-block percentage metrics found.")
        return

    rows.sort()
    data = [(str(block), str(exec), str(merkle), str(store)) for block, exec, merkle, store in rows]
    headers = ("Block", "Exec%", "Merkle%", "Store%")
    widths = [max(len(value) for value in column) for column in zip(headers, *data)]

    def format_row(values: tuple[str, ...] | list[str]) -> str:
        return "| " + " | ".join(value.rjust(width) for value, width in zip(values, widths)) + " |"

    border = "+-" + "-+-".join("-" * width for width in widths) + "-+"
    print()
    print(border)
    print(format_row(headers))
    print(border)
    for row in data:
        print(format_row(row))
    print(border)


def main() -> int:
    args = parse_args()
    log_path: Path = args.log_file

    if not log_path.exists():
        print(f"No log file {log_path} found; skipping throughput summary.", file=sys.stderr)
        return 1

    non_zero_throughput, rows = collect_metrics(log_path)
    print_summary(non_zero_throughput)
    print_table(rows)
    return 0


if __name__ == "__main__":
    sys.exit(main())
