use std::{collections::HashMap, path::Path, path::PathBuf};

use bytes::Bytes;
use clap::Parser;
use ethrex_common::types::{Genesis, GenesisAccount};
use ethrex_common::{Address, H160, U256};
use ethrex_l2::utils::test_data_io::read_genesis_file;
use ethrex_l2_sdk::{
    COMMON_BRIDGE_L2_ADDRESS, L2_TO_L1_MESSENGER_ADDRESS, address_to_word, get_erc1967_slot,
};
use genesis_tool::genesis::write_genesis_as_json;

#[derive(Parser, Default)]
pub struct SystemContractsUpdaterOptions {
    #[arg(
        long,
        value_name = "PATH",
        env = "ETHREX_DEPLOYER_GENESIS_L1_PATH",
        help_heading = "Deployer options",
        help = "Path to the genesis file. The default is ../../fixtures/genesis/l1-dev.json"
    )]
    pub l2_genesis_path: PathBuf,
}

#[allow(clippy::enum_variant_names)]
#[derive(Debug, thiserror::Error)]
pub enum SystemContractsUpdaterError {
    #[error("Failed to deploy contract: {0}")]
    FailedToDecodeRuntimeCode(#[from] hex::FromHexError),
    #[error("Failed to serialize modified genesis: {0}")]
    FailedToSerializeModifiedGenesis(#[from] serde_json::Error),
    #[error("Failed to write modified genesis file: {0}")]
    FailedToWriteModifiedGenesisFile(#[from] std::io::Error),
    #[error("Failed to read path: {0}")]
    InvalidPath(String),
    #[error(
        "Contract bytecode not found. Make sure to compile the updater with `COMPILE_CONTRACTS` set."
    )]
    BytecodeNotFound,
}

/// Bytecode of the CommonBridgeL2 contract.
/// This is generated by the [build script](./build.rs).
const COMMON_BRIDGE_L2_RUNTIME: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/CommonBridgeL2.bytecode"
));

/// Bytecode of the L2ToL1Messenger contract.
/// This is generated by the [build script](./build.rs).
const L2_TO_L1_MESSENGER_RUNTIME: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/L2ToL1Messenger.bytecode"
));

/// Bytecode of the L2Upgradeable contract.
/// This is generated by the [build script](./build.rs).
const L2_UPGRADEABLE_RUNTIME: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/UpgradeableSystemContract.bytecode"
));

/// Address authorized to perform system contract upgrades
/// 0x000000000000000000000000000000000000f000
pub const ADMIN_ADDRESS: Address = H160([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0x00,
]);

/// Mask used to derive the initial implementation address
/// 0x0000000000000000000000000000000000001000
pub const IMPL_MASK: Address = H160([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x00,
]);

fn main() -> Result<(), SystemContractsUpdaterError> {
    let opts = SystemContractsUpdaterOptions::parse();
    update_genesis_file(&opts.l2_genesis_path)?;
    Ok(())
}

fn add_with_proxy(
    genesis: &mut Genesis,
    address: Address,
    code: Vec<u8>,
) -> Result<(), SystemContractsUpdaterError> {
    let impl_address = address ^ IMPL_MASK;

    if code.is_empty() {
        return Err(SystemContractsUpdaterError::BytecodeNotFound);
    }

    genesis.alloc.insert(
        impl_address,
        GenesisAccount {
            code: Bytes::from(code),
            storage: HashMap::new(),
            balance: U256::zero(),
            nonce: 1,
        },
    );

    let mut storage = HashMap::new();
    storage.insert(
        get_erc1967_slot("eip1967.proxy.implementation"),
        address_to_word(impl_address),
    );
    storage.insert(
        get_erc1967_slot("eip1967.proxy.admin"),
        address_to_word(ADMIN_ADDRESS),
    );
    genesis.alloc.insert(
        address,
        GenesisAccount {
            code: Bytes::from(L2_UPGRADEABLE_RUNTIME),
            storage,
            balance: U256::zero(),
            nonce: 1,
        },
    );
    Ok(())
}

pub fn update_genesis_file(l2_genesis_path: &PathBuf) -> Result<(), SystemContractsUpdaterError> {
    let mut genesis = read_genesis_file(l2_genesis_path.to_str().ok_or(
        SystemContractsUpdaterError::InvalidPath(
            "Failed to convert l2 genesis path to string".to_string(),
        ),
    )?);

    add_with_proxy(
        &mut genesis,
        COMMON_BRIDGE_L2_ADDRESS,
        COMMON_BRIDGE_L2_RUNTIME.to_vec(),
    )?;

    add_with_proxy(
        &mut genesis,
        L2_TO_L1_MESSENGER_ADDRESS,
        L2_TO_L1_MESSENGER_RUNTIME.to_vec(),
    )?;

    write_genesis_as_json(genesis, Path::new(l2_genesis_path)).map_err(std::io::Error::other)?;

    Ok(())
}
