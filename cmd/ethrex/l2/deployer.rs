use std::{
    fs::{File, OpenOptions, read_to_string},
    io::{BufReader, BufWriter, Write},
    path::PathBuf,
    process::{Command, Stdio},
    str::FromStr,
};

use bytes::Bytes;
use clap::{ArgAction, Parser};
use ethrex_common::{
    Address, H160, U256,
    types::{Genesis, TxType},
};
use ethrex_config::networks::LOCAL_DEVNETL2_GENESIS_CONTENTS;
use ethrex_l2::sequencer::utils::DEV_MODE_ADDRESS;
use ethrex_l2_common::calldata::Value;
use ethrex_l2_rpc::signer::{LocalSigner, Signer};
use ethrex_l2_sdk::{
    DeployError, build_generic_tx, call_contract, create2_deploy_from_bytecode,
    deploy_with_proxy_from_bytecode, send_generic_transaction,
};
use ethrex_rpc::{
    EthClient,
    clients::{EthClientError, Overrides, eth::errors::CalldataEncodeError},
    types::block_identifier::{BlockIdentifier, BlockTag},
};
use keccak_hash::H256;
use tracing::{debug, error, info, trace, warn};

use secp256k1::SecretKey;

use crate::{l2::EthOptions, utils::parse_private_key};

/// Bytecode of the OnChainProposer contract.
/// This is generated by the [build script](./build.rs).
const ON_CHAIN_PROPOSER_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/OnChainProposer.bytecode"
));

/// Bytecode of the CommonBridge contract.
/// This is generated by the [build script](./build.rs).
const COMMON_BRIDGE_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/CommonBridge.bytecode"
));

/// Bytecode of the based OnChainProposer contract.
/// This is generated by the [build script](./build.rs).
const ON_CHAIN_PROPOSER_BASED_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/OnChainProposerBased.bytecode"
));

/// Bytecode of the SequencerRegistry contract.
/// This is generated by the [build script](./build.rs).
const SEQUENCER_REGISTRY_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/SequencerRegistry.bytecode"
));

/// Bytecode of the SP1Verifier contract.
/// This is generated by the [build script](./build.rs).
const SP1_VERIFIER_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/SP1Verifier.bytecode"
));

/// SP1 verification key.
#[cfg(feature = "sp1")]
const SP1_VERIFICATION_KEY: Option<&str> = Some(include_str!(concat!(
    "../../../crates/l2/prover/zkvm/interface/sp1/out/riscv32im-succinct-zkvm-vk"
)));
#[cfg(not(feature = "sp1"))]
const SP1_VERIFICATION_KEY: Option<&str> = None;

/// RISC0 verification key.
#[cfg(feature = "risc0")]
const RISC0_VERIFICATION_KEY: Option<&str> = Some(include_str!(concat!(
    "../../../crates/l2/prover/zkvm/interface/risc0/out/riscv32im-risc0-vk"
)));
#[cfg(not(feature = "risc0"))]
const RISC0_VERIFICATION_KEY: Option<&str> = None;

const INITIALIZE_ON_CHAIN_PROPOSER_SIGNATURE_BASED: &str = "initialize(bool,address,address,address,address,address,bytes32,bytes32,bytes32,address,uint256)";
const INITIALIZE_ON_CHAIN_PROPOSER_SIGNATURE: &str = "initialize(bool,address,address,address,address,address,bytes32,bytes32,bytes32,address[],uint256)";
const INITIALIZE_BRIDGE_ADDRESS_SIGNATURE: &str = "initializeBridgeAddress(address)";
const TRANSFER_OWNERSHIP_SIGNATURE: &str = "transferOwnership(address)";
const ACCEPT_OWNERSHIP_SIGNATURE: &str = "acceptOwnership()";
const INITIALIZE_COMMON_BRIDGE_SIGNATURE: &str = "initialize(address,address,uint256)";
const INITIALIZE_SEQUENCER_REGISTRY_SIGNATURE: &str = "initialize(address,address)";

#[derive(Parser)]
pub struct DeployerOptions {
    #[command(flatten)]
    pub eth_options: EthOptions,
    // Deployer options
    /// Private key from which the contracts will be deployed from.
    #[arg(
        long = "deployer.private-key",
        value_name = "PRIVATE_KEY",
        value_parser = parse_private_key,
        env = "ETHREX_DEPLOYER_L1_PRIVATE_KEY",
        help_heading = "Deployer options",
    )]
    pub private_key: SecretKey,
    /// Write the addresses of deployed contracts in a .env file format.
    #[arg(
        long = "deployer.env-file",
        value_name = "PATH",
        env = "ETHREX_DEPLOYER_ENV_FILE_PATH",
        help_heading = "Deployer options"
    )]
    pub env_file_path: Option<PathBuf>,
    /// Path to a file containing a list private keys, one per line.
    ///
    /// If set, a deposit will be done from those accounts via the newly created bridge.
    /// Used for dev purposes.
    #[arg(
        long = "deployer.deposit-accounts",
        value_name = "PATH",
        env = "ETHREX_DEPLOYER_DEPOSIT_PRIVATE_KEYS_FILE_PATH",
        help_heading = "Deployer options"
    )]
    pub deposit_private_keys_file: Option<PathBuf>,
    /// Salt to use with CREATE2 deterministic deployer. Defaults to random.
    #[arg(
        long = "deployer.deterministic-salt",
        value_name = "H256",
        env = "ETHREX_DEPLOYER_DETERMINISTIC_SALT",
        help_heading = "Deployer options"
    )]
    pub create2_salt: Option<H256>,
    /// Address of the OnChainProposer's owner. Defaults to the deployer account.
    #[arg(
        long = "deployer.on-chain-proposer-owner",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_ON_CHAIN_PROPOSER_OWNER_ADDRESS",
        help_heading = "Deployer options"
    )]
    pub on_chain_proposer_owner: Option<Address>,
    /// Private key of the OnChainProposer's owner, used for accepting the ownership.
    #[arg(
        long = "deployer.on-chain-proposer-owner-pk",
        value_name = "PRIVATE_KEY",
        env = "ETHREX_DEPLOYER_ON_CHAIN_PROPOSER_OWNER_PK",
        conflicts_with = "on_chain_proposer_owner",
        help_heading = "Deployer options"
    )]
    pub on_chain_proposer_owner_pk: Option<SecretKey>,
    /// Address of the CommonBridge' owner. Defaults to the deployer account.
    #[arg(
        long = "deployer.bridge-owner",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_BRIDGE_OWNER_ADDRESS",
        help_heading = "Deployer options"
    )]
    pub bridge_owner: Option<Address>,
    /// Deploy the SP1 verifier contract and use its address.
    #[arg(
        long = "deployer.deploy-sp1",
        value_name = "BOOL",
        default_value = "false",
        default_missing_value = "true",
        num_args = 0..=1,
        require_equals = true,
        action = ArgAction::Set,
        hide_possible_values = true,
        env = "ETHREX_DEPLOYER_DEPLOY_SP1_VERIFIER",
        conflicts_with = "sp1_verifier_address",
        help_heading = "Deployer options",
    )]
    pub deploy_sp1_verifier: bool,
    /// Deploy the TDX verifier contracts and use its address.
    #[arg(
        long = "deployer.deploy-tdx",
        value_name = "BOOL",
        default_value = "false",
        default_missing_value = "true",
        num_args = 0..=1,
        require_equals = true,
        action = ArgAction::Set,
        hide_possible_values = true,
        env = "ETHREX_DEPLOYER_DEPLOY_TDX_VERIFIER",
        conflicts_with = "tdx_verifier_address",
        help_heading = "Deployer options",
    )]
    pub deploy_tdx_verifier: bool,

    // L2 options
    /// Path to the L2 genesis file
    #[arg(
        long = "l2.genesis",
        value_name = "PATH",
        env = "ETHREX_DEPLOYER_GENESIS_L2_PATH",
        required_unless_present = "use_dev_genesis",
        required_if_eq("use_dev_genesis", "false"),
        help_heading = "L2 options"
    )]
    pub genesis_l2_path: Option<PathBuf>,
    /// Use a development-purpose genesis instead of a custom one.
    #[arg(
        long = "l2.dev-genesis",
        value_name = "BOOL",
        default_value = "false",
        default_missing_value = "true",
        num_args = 0..=1,
        require_equals = true,
        action = ArgAction::Set,
        hide_possible_values = true,
        env = "ETHREX_DEPLOYER_DEV_GENESIS",
        help_heading = "L2 options",
    )]
    pub use_dev_genesis: bool,
    /// Address of the account that commits the batches to L1.
    #[arg(
        long = "l2.l1-committer",
        default_value = "0x3d1e15a1a55578f7c920884a9943b3b35d0d885b",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_L1_COMMITTER_ADDRESS",
        help_heading = "L2 options"
    )]
    pub l1_committer: Address,
    /// Address of the account that sends the proofs to L1 to be verified.
    #[arg(
        long = "l2.l1-proof-sender",
        default_value = "0xE25583099BA105D9ec0A67f5Ae86D90e50036425",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_L1_PROOF_SENDER_ADDRESS",
        help_heading = "L2 options"
    )]
    pub l1_proof_sender: Address,
    /// Run on validium mode, meaning it will not publish state diffs to the L1.
    #[arg(
        long = "l2.validium",
        value_name = "BOOL",
        default_value = "false",
        default_missing_value = "true",
        num_args = 0..=1,
        require_equals = true,
        action = ArgAction::Set,
        hide_possible_values = true,
        env = "ETHREX_DEPLOYER_VALIDIUM",
        help_heading = "L2 options",
    )]
    pub validium: bool,
    /// Deadline, in seconds, for the sequencer to process a privileged transaction.
    #[arg(
        long = "l2.inclusion-max-wait",
        value_name = "SECONDS",
        default_value = "3000",
        env = "ETHREX_DEPLOYER_ON_CHAIN_PROPOSER_INCUSION_MAX_WAIT",
        help_heading = "L2 options"
    )]
    pub inclusion_max_wait: u64,

    // Verifiers options
    /// L1 address of the RISC0 verifier. If not set, contract will omit RISC0 verification.
    // TODO: This should work side by side with a risc0_deploy_verifier flag.
    #[arg(
        long = "verifier.risc0",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_RISC0_CONTRACT_VERIFIER_ADDRESS",
        help_heading = "Verifiers options"
    )]
    pub risc0_verifier_address: Option<Address>,
    /// RISC0 Image ID (verification key).
    #[arg(
        long = "verifier.risc0-vk",
        value_name = "PATH",
        env = "ETHREX_RISC0_VERIFICATION_KEY",
        conflicts_with = "risc0_vk_path",
        help_heading = "Verifiers options"
    )]
    pub risc0_vk: Option<H256>,
    /// Path to the RISC0 Image ID (verification key).
    #[arg(
        long = "verifier.risc0-vk-path",
        value_name = "PATH",
        env = "ETHREX_RISC0_VERIFICATION_KEY_PATH",
        conflicts_with = "risc0_vk",
        help_heading = "Verifiers options"
    )]
    pub risc0_vk_path: Option<PathBuf>,
    /// L1 address of the SP1 verifier. If not set, contract will omit SP1 verification.
    #[arg(
        long = "verifier.sp1",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_SP1_CONTRACT_VERIFIER_ADDRESS",
        conflicts_with = "sp1_deploy_verifier",
        help_heading = "Verifiers options"
    )]
    pub sp1_verifier_address: Option<Address>,
    /// SP1 verification key.
    #[arg(
        long = "verifier.sp1-vk",
        value_name = "PATH",
        env = "ETHREX_SP1_VERIFICATION_KEY",
        conflicts_with = "sp1_vk_path",
        help_heading = "Verifiers options"
    )]
    pub sp1_vk: Option<H256>,
    /// Path to the SP1 verification key.
    #[arg(
        long = "verifier.sp1-vk-path",
        // default_value_t = format!("{}/../prover/zkvm/interface/sp1/out/riscv32im-succinct-zkvm-vk", env!("CARGO_MANIFEST_DIR")).into(),
        value_name = "PATH",
        env = "ETHREX_SP1_VERIFICATION_KEY_PATH",
        conflicts_with = "sp1_vk",
        help_heading = "Verifiers options",
    )]
    pub sp1_vk_path: Option<PathBuf>,
    /// L1 address of the TDX verifier. If not set, contract will omit TDX verification.
    #[arg(
        long = "verifier.tdx",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_TDX_CONTRACT_VERIFIER_ADDRESS",
        conflicts_with = "tdx_deploy_verifier",
        help_heading = "Verifiers options"
    )]
    pub tdx_verifier_address: Option<Address>,
    /// L1 address of the Aligned Aggregator. If not set, contract will omit Aligned verification.
    #[arg(
        long = "verifier.aligned-aggregator",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_ALIGNED_AGGREGATOR_ADDRESS",
        help_heading = "Verifiers options"
    )]
    pub aligned_aggregator_address: Option<Address>,

    // L2 Based options
    /// Deploy the SequencerRegistry contract and the based version of OnChainProposer.
    #[arg(
        long = "deployer.based",
        value_name = "BOOL",
        default_value = "false",
        default_missing_value = "true",
        num_args = 0..=1,
        require_equals = true,
        action = ArgAction::Set,
        hide_possible_values = true,
        env = "ETHREX_DEPLOYER_DEPLOY_BASED_CONTRACTS",
        help_heading = "L2 Based options",
    )]
    pub deploy_based_contracts: bool,
    /// Address of the SequencerRegistry' owner. Defaults to the deployer account.
    #[arg(
        long = "deployer.sequencer-registry-owner",
        value_name = "ADDRESS",
        env = "ETHREX_DEPLOYER_SEQUENCER_REGISTRY_OWNER_ADDRESS",
        help_heading = "L2 Based options"
    )]
    pub sequencer_registry_owner: Option<Address>,
}

impl Default for DeployerOptions {
    fn default() -> Self {
        Self {
            eth_options: EthOptions::default(),
            #[allow(clippy::unwrap_used)]
            // 0x385c546456b6a603a1cfcaa9ec9494ba4832da08dd6bcf4de9a71e4a01b74924
            private_key: SecretKey::from_slice(
                H256([
                    0x38, 0x5c, 0x54, 0x64, 0x56, 0xb6, 0xa6, 0x03, 0xa1, 0xcf, 0xca, 0xa9, 0xec,
                    0x94, 0x94, 0xba, 0x48, 0x32, 0xda, 0x08, 0xdd, 0x6b, 0xcf, 0x4d, 0xe9, 0xa7,
                    0x1e, 0x4a, 0x01, 0xb7, 0x49, 0x24,
                ])
                .as_bytes(),
            )
            .unwrap(),
            env_file_path: Some(PathBuf::from(".env")),
            deposit_private_keys_file: None,
            genesis_l2_path: None,
            // 0x3d1e15a1a55578f7c920884a9943b3b35d0d885b
            l1_committer: H160([
                0x3d, 0x1e, 0x15, 0xa1, 0xa5, 0x55, 0x78, 0xf7, 0xc9, 0x20, 0x88, 0x4a, 0x99, 0x43,
                0xb3, 0xb3, 0x5d, 0x0d, 0x88, 0x5b,
            ]),
            // 0xE25583099BA105D9ec0A67f5Ae86D90e50036425
            l1_proof_sender: H160([
                0xe2, 0x55, 0x83, 0x09, 0x9b, 0xa1, 0x05, 0xd9, 0xec, 0x0a, 0x67, 0xf5, 0xae, 0x86,
                0xd9, 0x0e, 0x50, 0x03, 0x64, 0x25,
            ]),
            risc0_verifier_address: None,
            sp1_verifier_address: None,
            deploy_sp1_verifier: false,
            tdx_verifier_address: None,
            deploy_tdx_verifier: false,
            aligned_aggregator_address: None,
            create2_salt: None,
            validium: false,
            on_chain_proposer_owner: None,
            on_chain_proposer_owner_pk: None,
            bridge_owner: None,
            sp1_vk: None,
            risc0_vk: None,
            sp1_vk_path: None,
            risc0_vk_path: None,
            deploy_based_contracts: false,
            sequencer_registry_owner: None,
            inclusion_max_wait: 3000,
            use_dev_genesis: true,
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum DeployerError {
    #[error("The path is not a valid utf-8 string")]
    FailedToGetStringFromPath,
    #[error("Deployer setup error: {0} not set")]
    ConfigValueNotSet(String),
    #[error("Deployer EthClient error: {0}")]
    EthClientError(#[from] EthClientError),
    #[error("Deployer decoding error: {0}")]
    DecodingError(String),
    #[error("Failed to encode calldata: {0}")]
    CalldataEncodeError(#[from] CalldataEncodeError),
    #[error("Failed to deploy contract: {0}")]
    FailedToDeployContract(#[from] DeployError),
    #[error("Deployment subtask failed: {0}")]
    DeploymentSubtaskFailed(String),
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("IO error: {0}")]
    IO(#[from] std::io::Error),
    #[error(
        "Contract bytecode not found. Make sure to compile the deployer with `COMPILE_CONTRACTS` set."
    )]
    BytecodeNotFound,
    #[error("Failed to read or parse genesis: {0}")]
    GenesisError(String),
}

#[derive(Clone, Copy)]
pub struct ContractAddresses {
    pub on_chain_proposer_address: Address,
    pub bridge_address: Address,
    pub sp1_verifier_address: Address,
    pub risc0_verifier_address: Address,
    pub tdx_verifier_address: Address,
    pub sequencer_registry_address: Address,
    pub aligned_aggregator_address: Address,
}

pub async fn deploy_l1_contracts(
    opts: DeployerOptions,
) -> Result<ContractAddresses, DeployerError> {
    debug!("Starting deployer binary");

    #[cfg(not(feature = "sp1"))]
    if (opts.deploy_sp1_verifier || opts.sp1_verifier_address.is_some())
        && (opts.sp1_vk.is_none() && opts.sp1_vk_path.is_none())
    {
        return Err(DeployerError::ConfigValueNotSet(
            "--verifier.sp1-vk and --verifier.sp1-vk-path".to_string(),
        ));
    }

    #[cfg(not(feature = "risc0"))]
    if opts.risc0_verifier_address.is_some()
        && (opts.risc0_vk.is_none() && opts.risc0_vk_path.is_none())
    {
        return Err(DeployerError::ConfigValueNotSet(
            "--verifier.risc0-vk and --verifier.risc0-vk-path".to_string(),
        ));
    }

    let signer: Signer = LocalSigner::new(opts.private_key).into();

    let eth_client = EthClient::new_with_config(
        opts.eth_options
            .rpc_url
            .iter()
            .map(|url| url.as_str())
            .collect(),
        opts.eth_options.max_number_of_retries,
        opts.eth_options.backoff_factor,
        opts.eth_options.min_retry_delay,
        opts.eth_options.max_retry_delay,
        Some(opts.eth_options.maximum_allowed_max_fee_per_gas),
        Some(opts.eth_options.maximum_allowed_max_fee_per_blob_gas),
    )?;

    let contract_addresses = deploy_contracts(&eth_client, &opts, &signer).await?;

    initialize_contracts(contract_addresses, &eth_client, &opts, &signer).await?;

    if opts.deposit_private_keys_file.is_some() {
        let _ = make_deposits(contract_addresses.bridge_address, &eth_client, &opts)
            .await
            .inspect_err(|err| {
                warn!("Failed to make deposits: {err}");
            });
    }

    if let Some(env_file_path) = opts.env_file_path {
        write_contract_addresses_to_env(contract_addresses, env_file_path)?;
    }

    debug!("Deployer binary finished successfully");
    Ok(contract_addresses)
}

async fn deploy_contracts(
    eth_client: &EthClient,
    opts: &DeployerOptions,
    deployer: &Signer,
) -> Result<ContractAddresses, DeployerError> {
    info!("Deploying OnChainProposer");

    let salt = opts.create2_salt.unwrap_or_else(H256::random);
    debug!("Salt used: {salt:#x}");

    let bytecode = if opts.deploy_based_contracts {
        ON_CHAIN_PROPOSER_BASED_BYTECODE.to_vec()
    } else {
        ON_CHAIN_PROPOSER_BYTECODE.to_vec()
    };

    if bytecode.is_empty() {
        return Err(DeployerError::BytecodeNotFound);
    }

    let on_chain_proposer_deployment =
        deploy_with_proxy_from_bytecode(deployer, eth_client, &bytecode, salt.as_bytes()).await?;
    info!(
        address =? on_chain_proposer_deployment.implementation_address,
        tx_hash =? on_chain_proposer_deployment.implementation_tx_hash,
        "OnChainProposer implementation deployed"
    );
    info!(
        address =? on_chain_proposer_deployment.proxy_address,
        tx_hash =? on_chain_proposer_deployment.proxy_tx_hash,
        "OnChainProposer proxy deployed"
    );

    info!("Deploying CommonBridge");

    let bridge_deployment = deploy_with_proxy_from_bytecode(
        deployer,
        eth_client,
        COMMON_BRIDGE_BYTECODE,
        salt.as_bytes(),
    )
    .await?;

    info!(
        address =? bridge_deployment.implementation_address,
        tx_hash =? bridge_deployment.implementation_tx_hash,
        "CommonBridge implementation deployed"
    );
    info!(
        address =? bridge_deployment.proxy_address,
        tx_hash =? bridge_deployment.proxy_tx_hash,
        "CommonBridge proxy deployed"
    );

    let sequencer_registry_deployment = if opts.deploy_based_contracts {
        info!("Deploying SequencerRegistry");

        let sequencer_registry_deployment = deploy_with_proxy_from_bytecode(
            deployer,
            eth_client,
            SEQUENCER_REGISTRY_BYTECODE,
            salt.as_bytes(),
        )
        .await?;

        info!(
            address =? sequencer_registry_deployment.implementation_address,
            tx_hash =? sequencer_registry_deployment.implementation_tx_hash,
            "SequencerRegistry implementation deployed"
        );
        info!(
            address =? sequencer_registry_deployment.proxy_address,
            tx_hash =? sequencer_registry_deployment.proxy_tx_hash,
            "SequencerRegistry proxy deployed"
        );
        sequencer_registry_deployment
    } else {
        Default::default()
    };

    // TODO: Add Risc0Verifier deployment
    let risc0_verifier_address = opts.risc0_verifier_address.unwrap_or(DEV_MODE_ADDRESS);

    let sp1_verifier_address = if opts.deploy_sp1_verifier {
        info!("Deploying SP1 verifier");
        create2_deploy_from_bytecode(
            &[],
            SP1_VERIFIER_BYTECODE,
            deployer,
            salt.as_bytes(),
            eth_client,
        )
        .await
        .map(|(tx_hash, address)| {
            info!(?address, ?tx_hash, "SP1 verifier deployed");
            address
        })?
    } else {
        opts.sp1_verifier_address.unwrap_or(DEV_MODE_ADDRESS)
    };

    let tdx_verifier_address = if opts.deploy_tdx_verifier {
        info!("Deploying TDX verifier");
        deploy_tdx_contracts(opts, on_chain_proposer_deployment.proxy_address)
            .inspect(|address| info!(?address, "TDX verifier deployed"))?
    } else {
        opts.tdx_verifier_address.unwrap_or(DEV_MODE_ADDRESS)
    };

    let aligned_aggregator_address = opts.aligned_aggregator_address.unwrap_or(DEV_MODE_ADDRESS);

    debug!(
        on_chain_proposer_proxy_address = ?on_chain_proposer_deployment.proxy_address,
        bridge_proxy_address = ?bridge_deployment.proxy_address,
        on_chain_proposer_implementation_address = ?on_chain_proposer_deployment.implementation_address,
        bridge_implementation_address = ?bridge_deployment.implementation_address,
        sp1_verifier_address = ?sp1_verifier_address,
        risc0_verifier_address = ?risc0_verifier_address,
        tdx_verifier_address = ?tdx_verifier_address,
        "Contracts deployed"
    );

    Ok(ContractAddresses {
        on_chain_proposer_address: on_chain_proposer_deployment.proxy_address,
        bridge_address: bridge_deployment.proxy_address,
        sp1_verifier_address,
        risc0_verifier_address,
        tdx_verifier_address,
        sequencer_registry_address: sequencer_registry_deployment.proxy_address,
        aligned_aggregator_address,
    })
}

fn deploy_tdx_contracts(
    opts: &DeployerOptions,
    on_chain_proposer: Address,
) -> Result<Address, DeployerError> {
    Command::new("make")
        .arg("deploy-all")
        .env("PRIVATE_KEY", hex::encode(opts.private_key.as_ref()))
        // TODO: This can panic
        .env("RPC_URL", &opts.eth_options.rpc_url[0])
        .env("ON_CHAIN_PROPOSER", format!("{on_chain_proposer:#x}"))
        .current_dir("tee/contracts")
        .stdout(Stdio::null())
        .spawn()
        .map_err(|err| {
            DeployerError::DeploymentSubtaskFailed(format!("Failed to spawn make: {err}"))
        })?
        .wait()
        .map_err(|err| {
            DeployerError::DeploymentSubtaskFailed(format!("Failed to wait for make: {err}"))
        })?;

    let address = read_tdx_deployment_address("TDXVerifier");
    Ok(address)
}

fn read_tdx_deployment_address(name: &str) -> Address {
    let path = format!("tee/contracts/deploydeps/automata-dcap-attestation/evm/deployment/{name}");
    let Ok(contents) = read_to_string(path) else {
        return Address::zero();
    };
    Address::from_str(&contents).unwrap_or(Address::zero())
}

fn read_vk(path: &PathBuf) -> H256 {
    let Ok(str) = std::fs::read_to_string(path) else {
        warn!(
            ?path,
            "Failed to read verification key file, will use 0x00..00, this is expected in dev mode"
        );
        return H256::zero();
    };

    let cleaned = str.trim().strip_prefix("0x").unwrap_or(&str);

    hex::decode(cleaned)
        .and_then(|bytes| {
            if bytes.len() == 32 {
                Ok(H256::from_slice(&bytes))
            } else {
                Err(hex::FromHexError::InvalidStringLength)
            }
        })
        .unwrap_or_else(|err| {
            warn!(
                ?path,
                ?err,
                "Failed to decode hex string, will use 0x00..00. This is expected in dev mode",
            );
            H256::zero()
        })
}

async fn initialize_contracts(
    contract_addresses: ContractAddresses,
    eth_client: &EthClient,
    opts: &DeployerOptions,
    initializer: &Signer,
) -> Result<(), DeployerError> {
    trace!("Initializing contracts");

    let genesis: Genesis = if opts.use_dev_genesis {
        serde_json::from_str(LOCAL_DEVNETL2_GENESIS_CONTENTS)
            .map_err(|e| DeployerError::GenesisError(e.to_string()))?
    } else {
        read_genesis_file(
            &opts
                .genesis_l2_path
                .clone()
                .ok_or(DeployerError::ConfigValueNotSet("--l2.genesis".to_string()))?,
        )?
    };

    let sp1_vk = opts
        .sp1_vk_path
        .as_ref()
        .map(read_vk)
        .or(opts.sp1_vk)
        .or(SP1_VERIFICATION_KEY
            .map(|vk| H256::from_str(vk).expect("Invalid embeded SP1 verification key")))
        .unwrap_or(H256::zero());

    let risc0_vk = opts
        .risc0_vk_path
        .as_ref()
        .map(read_vk)
        .or(opts.risc0_vk)
        .or(RISC0_VERIFICATION_KEY
            .map(|vk| H256::from_str(vk).expect("Invalid embeded RISC0 verification key")))
        .unwrap_or(H256::zero());

    let initializer_address = initializer.address();

    info!("Initializing OnChainProposer");

    if opts.deploy_based_contracts {
        // Initialize OnChainProposer with Based config and SequencerRegistry
        let calldata_values = vec![
            Value::Bool(opts.validium),
            Value::Address(initializer_address),
            Value::Address(contract_addresses.risc0_verifier_address),
            Value::Address(contract_addresses.sp1_verifier_address),
            Value::Address(contract_addresses.tdx_verifier_address),
            Value::Address(contract_addresses.aligned_aggregator_address),
            Value::FixedBytes(sp1_vk.0.to_vec().into()),
            Value::FixedBytes(risc0_vk.0.to_vec().into()),
            Value::FixedBytes(genesis.compute_state_root().0.to_vec().into()),
            Value::Address(contract_addresses.sequencer_registry_address),
            Value::Uint(genesis.config.chain_id.into()),
        ];

        trace!("OnChainProposer initialization calldata values: {calldata_values:?}");

        let initialize_tx_hash = call_contract(
            eth_client,
            initializer,
            contract_addresses.on_chain_proposer_address,
            INITIALIZE_ON_CHAIN_PROPOSER_SIGNATURE_BASED,
            calldata_values,
        )
        .await?;

        info!(tx_hash =? initialize_tx_hash, "OnChainProposer initialized");
        info!("Initializing SequencerRegistry");

        let calldata_values = vec![
            Value::Address(opts.sequencer_registry_owner.unwrap_or(initializer_address)),
            Value::Address(contract_addresses.on_chain_proposer_address),
        ];

        trace!("SequencerRegistry initialization calldata values: {calldata_values:?}");

        let initialize_tx_hash = call_contract(
            eth_client,
            initializer,
            contract_addresses.sequencer_registry_address,
            INITIALIZE_SEQUENCER_REGISTRY_SIGNATURE,
            calldata_values,
        )
        .await?;

        info!(tx_hash =? initialize_tx_hash, "SequencerRegistry initialized");
    } else {
        // Initialize only OnChainProposer without Based config
        let calldata_values = vec![
            Value::Bool(opts.validium),
            Value::Address(initializer_address),
            Value::Address(contract_addresses.risc0_verifier_address),
            Value::Address(contract_addresses.sp1_verifier_address),
            Value::Address(contract_addresses.tdx_verifier_address),
            Value::Address(contract_addresses.aligned_aggregator_address),
            Value::FixedBytes(sp1_vk.0.to_vec().into()),
            Value::FixedBytes(risc0_vk.0.to_vec().into()),
            Value::FixedBytes(genesis.compute_state_root().0.to_vec().into()),
            Value::Array(vec![
                Value::Address(opts.l1_committer),
                Value::Address(opts.l1_proof_sender),
            ]),
            Value::Uint(genesis.config.chain_id.into()),
        ];

        trace!("OnChainProposer initialization calldata values: {calldata_values:?}");

        let initialize_tx_hash = call_contract(
            eth_client,
            initializer,
            contract_addresses.on_chain_proposer_address,
            INITIALIZE_ON_CHAIN_PROPOSER_SIGNATURE,
            calldata_values,
        )
        .await?;

        info!(tx_hash =? initialize_tx_hash, "OnChainProposer initialized");
    }

    let calldata_values = vec![Value::Address(contract_addresses.bridge_address)];

    trace!("OnChainProposer bridge address initialization calldata values: {calldata_values:?}");

    let initialize_bridge_address_tx_hash = call_contract(
        eth_client,
        initializer,
        contract_addresses.on_chain_proposer_address,
        INITIALIZE_BRIDGE_ADDRESS_SIGNATURE,
        calldata_values,
    )
    .await?;

    info!(
        tx_hash =? initialize_bridge_address_tx_hash,
        "OnChainProposer bridge address initialized"
    );

    if let Some(owner_pk) = opts.on_chain_proposer_owner_pk {
        let owner: Signer = LocalSigner::new(owner_pk).into();

        let tx_hash = transfer_ownership(
            eth_client,
            initializer,
            owner.address(),
            contract_addresses.on_chain_proposer_address,
        )
        .await?;

        info!(?tx_hash, to =? owner, "OnChainProposer ownership transfered but not accepted yet");

        let tx_hash = accept_ownership(
            eth_client,
            &owner,
            contract_addresses.on_chain_proposer_address,
        )
        .await?;

        info!(?tx_hash, "OnChainProposer ownership accepted");
    } else if let Some(owner) = opts.on_chain_proposer_owner {
        let tx_hash = transfer_ownership(
            eth_client,
            initializer,
            owner,
            contract_addresses.on_chain_proposer_address,
        )
        .await?;

        info!(?tx_hash, to =? owner, "OnChainProposer ownership transfered but not accepted yet");
    }

    info!("Initializing CommonBridge");

    let bridge_owner = opts.bridge_owner.unwrap_or(initializer_address);
    let calldata_values = vec![
        Value::Address(bridge_owner),
        Value::Address(contract_addresses.on_chain_proposer_address),
        Value::Uint(opts.inclusion_max_wait.into()),
    ];

    trace!("CommonBridge initialization calldata values: {calldata_values:?}");

    let initialize_tx_hash = call_contract(
        eth_client,
        initializer,
        contract_addresses.bridge_address,
        INITIALIZE_COMMON_BRIDGE_SIGNATURE,
        calldata_values,
    )
    .await?;

    info!(tx_hash =? initialize_tx_hash, "CommonBridge initialized");
    trace!("Contracts initialized");

    Ok(())
}

async fn transfer_ownership(
    eth_client: &EthClient,
    from: &Signer,
    to: Address,
    contract: Address,
) -> Result<H256, DeployerError> {
    let tx_hash = call_contract(
        eth_client,
        from,
        contract,
        TRANSFER_OWNERSHIP_SIGNATURE,
        vec![Value::Address(to)],
    )
    .await?;

    Ok(tx_hash)
}

async fn accept_ownership(
    eth_client: &EthClient,
    new_owner: &Signer,
    contract: Address,
) -> Result<H256, DeployerError> {
    let tx_hash = call_contract(
        eth_client,
        new_owner,
        contract,
        ACCEPT_OWNERSHIP_SIGNATURE,
        vec![],
    )
    .await?;

    Ok(tx_hash)
}

async fn make_deposits(
    bridge: Address,
    eth_client: &EthClient,
    opts: &DeployerOptions,
) -> Result<(), DeployerError> {
    trace!("Making deposits");

    let pks = read_to_string(opts.deposit_private_keys_file.clone().ok_or(
        DeployerError::ConfigValueNotSet("--deployer.deposit-accounts".to_string()),
    )?)
    .map_err(|_| DeployerError::FailedToGetStringFromPath)?;
    let private_keys: Vec<String> = pks
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| line.trim().to_string())
        .collect();

    let mut successful_deposits = 0;

    for pk in private_keys.iter() {
        let secret_key = parse_private_key(pk).map_err(|_| {
            DeployerError::DecodingError("Error while parsing private key".to_string())
        })?;
        let signer = Signer::Local(LocalSigner::new(secret_key));

        let get_balance = eth_client
            .get_balance(signer.address(), BlockIdentifier::Tag(BlockTag::Latest))
            .await?;
        let value_to_deposit = get_balance
            .checked_div(U256::from_str("2").unwrap_or(U256::zero()))
            .unwrap_or(U256::zero());

        let overrides = Overrides {
            value: Some(value_to_deposit),
            from: Some(signer.address()),
            ..Overrides::default()
        };

        let build = build_generic_tx(
            eth_client,
            TxType::EIP1559,
            bridge,
            signer.address(),
            Bytes::new(),
            overrides,
        )
        .await?;

        match send_generic_transaction(eth_client, build, &signer).await {
            Ok(hash) => {
                successful_deposits += 1;
                debug!(
                    address =? signer.address(),
                    ?value_to_deposit,
                    ?hash,
                    "Deposit transaction sent to L1"
                );
            }
            Err(e) => {
                error!(address =? signer.address(), ?value_to_deposit, "Failed to deposit");
                return Err(DeployerError::EthClientError(e));
            }
        }
    }

    info!(
        total_accounts = private_keys.len(),
        successful_deposits, "Deposits finished"
    );

    Ok(())
}

fn write_contract_addresses_to_env(
    contract_addresses: ContractAddresses,
    path: PathBuf,
) -> Result<(), DeployerError> {
    trace!("Writing contract addresses to .env file");

    if !path.is_file() {
        File::create(&path).map_err(|err| {
            DeployerError::InternalError(format!(
                "Failed to create .env file at {}: {err}",
                path.display()
            ))
        })?;
    }

    let env_file = OpenOptions::new().write(true).truncate(true).open(&path)?;
    let mut writer = BufWriter::new(env_file);

    writeln!(
        writer,
        r#"ETHREX_COMMITTER_ON_CHAIN_PROPOSER_ADDRESS={:#x}
ETHREX_WATCHER_BRIDGE_ADDRESS={:#x}
ETHREX_DEPLOYER_SP1_CONTRACT_VERIFIER_ADDRESS={:#x}
ETHREX_DEPLOYER_RISC0_CONTRACT_VERIFIER_ADDRESS={:#x}
ETHREX_DEPLOYER_ALIGNED_AGGREGATOR_ADDRESS={:#x}
ETHREX_DEPLOYER_TDX_CONTRACT_VERIFIER_ADDRESS={:#x}
ENCLAVE_ID_DAO={:#x}
FMSPC_TCB_DAO={:#x}
PCK_DAO={:#x}
PCS_DAO={:#x}
ETHREX_DEPLOYER_SEQUENCER_REGISTRY_ADDRESS={:#x}"#,
        contract_addresses.on_chain_proposer_address,
        contract_addresses.bridge_address,
        contract_addresses.sp1_verifier_address,
        contract_addresses.risc0_verifier_address,
        contract_addresses.aligned_aggregator_address,
        contract_addresses.tdx_verifier_address,
        read_tdx_deployment_address("AutomataEnclaveIdentityDao"),
        read_tdx_deployment_address("AutomataFmspcTcbDao"),
        read_tdx_deployment_address("AutomataPckDao"),
        read_tdx_deployment_address("AutomataPcsDao"),
        contract_addresses.sequencer_registry_address,
    )?;

    trace!(?path, "Contract addresses written to .env");
    Ok(())
}

pub fn read_genesis_file(path: &PathBuf) -> Result<Genesis, DeployerError> {
    let file = File::open(path).map_err(|e| DeployerError::GenesisError(e.to_string()))?;
    let genesis_reader = BufReader::new(file);
    serde_json::from_reader(genesis_reader).map_err(|e| DeployerError::GenesisError(e.to_string()))
}
